<?xml version="1.0" encoding="utf-8"?>
<!--
 *	MSS Code Factory 3.1 CFCore - Code Factory Core
 *
 *	Copyright (c) 2020 Mark Stephen Sobkow (msobkow@sasktel.net)
 *
 *	MSS Code Factory Code Factory Core is distributed under
 *	Mark Stephen Sobkow's Proprietary Core License, Version 1.0.
 *
 *	MSS Code Factory Code Factory Core is proprietary code
 *	which may not be modified in any way without a commercial license,
 *	not even if you are an educational institution.
 *
 *	The binaries may be used by the public to execute the MSS Code
 *	Factory tool itself, but they may not link their own applications
 *	to those binaries without a commercial use license.  A commercial
 *	use license will allow you to link to the binaries, and to extend
 *	the unmodified binaries and interfaces in your own application code.
 *
 *	MSS Code Factory Code Factory Core source is published so
 *	that you may study it for academic purposes, to perform security
 *	verification reviews, and for commercial use licensers to debug
 *	their applications.
 *
 *	Registered .edu educational institutions are permitted to install
 *	and link the binaries as if they had a commercial use license
 *	for research and courseware projects.  Such projects may not be
 *	used to produce commercial or business code, and may not be deployed
 *	to commercial or business interests, including the educational
 *	institution's own departments outside that performing the research
 *	or teaching the course.
 *
 *	Any use of MSS Code Factory Code Factory Core binaries or
 *	source in a production environment under any other circumstances
 *	without a commercial license from Mark Stephen Sobkow is strictly
 *	forbidden.
 *
 *	MSS Code Factory Code Factory Core is distributed in the
 *	hope that it will be useful, but WITHOUT ANY WARRANTY; without
 *	even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 *	PARTICULAR PURPOSE.
 *
 *	Donations to support MSS Code Factory Code Factory Core
 *	can be made at https://www.paypal.com/paypalme2/MarkSobkow
 *
 *	Please contact Mark Stephen Sobkow at msobkow@sasktel.net for commercial licensing.
 *-->
<MSSBam
		xmlns="uri://org.msscf/msscf/2.0.13/mssbam"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:xs="http://www.w3.org/2001/XMLSchema"
		xsi:schemaLocation="uri://org.msscf/msscf/2.0.13/mssbam file:/opt/msscf/2.0.13/xsd/mssbam-2.13.xsd"
		Name="CFGenKb"
		Revision="3.1"
		Description="MSS Code Factory CFGenKb - Code Factory Core"
		ProjectRoot="com.github.msobkow.CFCore.3.1" >
	<Tld Name="com" >
		<TopDomain Name="github" >
			<TopProject Name="msobkow" >
				<SubProject Name="CFCore" >
					<MajorVersion Name="3" >
						<MinorVersion Name="1" >
<SchemaDef Name="CFGenKb"
		DbName="GenKb31"
		Description="Code Factory Core"
		CopyrightHolder="Mark Stephen Sobkow"
		CopyrightPeriod="2020"
		AuthorEMail="msobkow@sasktel.net"
		ProjectURL="http://msobkow.github.com/"
		PublishURI="https://msscf.sourceforge.io/com-github-msobkow-CFCore-3-1-CFGenKb.xml"
		CommonLicenseName="Mark Stephen Sobkow's Proprietary Core License, Version 1.0" CommonLicenseCode="MSSCore10" >
			<CommonLicense>
MSS Code Factory 3.1 CFCore - Code Factory Core

Copyright (c) 2020 Mark Stephen Sobkow (msobkow@sasktel.net)

MSS Code Factory Code Factory Core is distributed under
Mark Stephen Sobkow's Proprietary Core License, Version 1.0.

MSS Code Factory Code Factory Core is proprietary code
which may not be modified in any way without a commercial license,
not even if you are an educational institution.

The binaries may be used by the public to execute the MSS Code
Factory tool itself, but they may not link their own applications
to those binaries without a commercial use license.  A commercial
use license will allow you to link to the binaries, and to extend
the unmodified binaries and interfaces in your own application code.

MSS Code Factory Code Factory Core source is published so
that you may study it for academic purposes, to perform security
verification reviews, and for commercial use licensers to debug
their applications.

Registered .edu educational institutions are permitted to install
and link the binaries as if they had a commercial use license
for research and courseware projects.  Such projects may not be
used to produce commercial or business code, and may not be deployed
to commercial or business interests, including the educational
institution's own departments outside that performing the research
or teaching the course.

Any use of MSS Code Factory Code Factory Core binaries or
source in a production environment under any other circumstances
without a commercial license from Mark Stephen Sobkow is strictly
forbidden.

MSS Code Factory Code Factory Core is distributed in the
hope that it will be useful, but WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.

Donations to support MSS Code Factory Code Factory Core
can be made at https://www.paypal.com/paypalme2/MarkSobkow

Please contact Mark Stephen Sobkow at msobkow@sasktel.net for commercial licensing.</CommonLicense>

	<EnumType Name="AuditActionEnum"
			IsNullable="false"
			MinValue="0"
			InitValue="0" >
		<EnumTag Name="Create" EnumCode="0" />
		<EnumTag Name="Update" EnumCode="1" />
		<EnumTag Name="Delete" EnumCode="2" />
	</EnumType>

	<Id64Gen Name="ClusterIdGen"
			IsNullable="false"
			DbName="ClusterIdGenSeq"
			MinValue="0"
			InitValue="0"
			Slice="1001"
			BlockSize="1" />

	<StringType Name="DeviceName"
			Label="Device Name"
			IsNullable="false"
			MaxLen="127"
			InitValue="" />

	<StringType Name="SHA512HexHash"
			Label="SHA-2 512 Hash encoded in hexadecimal"
			IsNullable="false"
			MaxLen="256"
			InitValue="" />

	<UuidGen Name="SecSessionIdGen"
			IsNullable="false"
			InitValue="654dbba0-eda7-11e1-aff1-0800200c9a66"
			Slice="1006"
			BlockSize="1" />

	<UuidGen Name="SecUserIdGen"
			IsNullable="false"
			InitValue="654dbba0-eda7-11e1-aff1-0800200c9a66"
			Slice="1007"
			BlockSize="1" />

	<Id64Gen Name="TenantIdGen"
			IsNullable="false"
			DbName="TenantIdGenSeq"
			MinValue="0"
			InitValue="0"
			Slice="1009"
			BlockSize="1" />

	<Table Name="Cluster"
			TableClassCode="a901"
			DbName="clus"
			ShortName="Clus"
			Label="Cluster"
			Description="A Cluster is an MSS Code Factory installation"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			LookupIndex="ClusterUDomNameIdx"
			LoaderBehaviour="Insert"
			SecScope="System" >
		<TableCol Name="Id"
				IsNullable="false"
				GenerateId="true"
				DataType="ClusterIdGen" />
		<StringCol Name="FullDomName"
				Label="Full Domain Name"
				IsNullable="false"
				MaxLen="192"
				InitValue="" />
		<StringCol Name="Description"
				Label="Cluster Description"
				IsNullable="false"
				MaxLen="128"
				InitValue="" />
		<PrimaryIndex Name="ClusterIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="cluster_pk"
				ShortName="PIdx"
				Suffix="IdIdx"
				Label="IdIdx" >
			<IndexCol Name="Id" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="ClusterUDomNameIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="cluster_xufdname"
				ShortName="UDom"
				Suffix="UDomNameIdx"
				Label="UDomNameIdx" >
			<IndexCol Name="FullDomName" IsAscending="true" />
		</Index>
		<Index Name="ClusterUDescrNameIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="cluster_xudescr"
				ShortName="UDescr"
				Suffix="UDescrIdx"
				Label="UDescrIdx" >
			<IndexCol Name="Description" IsAscending="true" />
		</Index>

		<CafeTableObjInterface>
	I$SecSchemaName$ClusterObj getSystemCluster();
</CafeTableObjInterface>

		<CafeTableObjImplementation>
	public I$SecSchemaName$ClusterObj getSystemCluster() {
		boolean transactionStarted = schema.beginTransaction();
		I$SecSchemaName$ClusterObj clusterObj;
		try {
			clusterObj = readClusterByUDomNameIdx( &quot;system&quot; );
			if( clusterObj == null ) {
				clusterObj = newInstance();
				I$SecSchemaName$ClusterEditObj clusterEdit = clusterObj.beginEdit();
				clusterEdit.setRequiredFullDomName( &quot;system&quot; );
				clusterObj = clusterEdit.create();
			}
			if( transactionStarted ) {
				schema.commit();
			}
		}
		catch( RuntimeException e ) {
			if( transactionStarted ) {
				try {
					schema.rollback();
				}
				catch( Exception e2 ) {
				}
			}
			throw e;
		}
		return( clusterObj );
	}
</CafeTableObjImplementation>

		<HPlusTableObjInterface>
	virtual I$SecSchemaName$ClusterObj* getSystemCluster() = 0;
</HPlusTableObjInterface>

		<CPlusTableObjInterface>
	virtual I$SecSchemaName$ClusterObj* getSystemCluster();
</CPlusTableObjInterface>

		<CPlusTableObjImplementation>
	I$SecSchemaName$ClusterObj* $SchemaName$$TableName$TableObj::getSystemCluster() {
		static const std::string S_System( "system" );
		bool transactionStarted = schema-&gt;beginTransaction();
		I$SecSchemaName$ClusterObj* clusterObj;
		try {
			clusterObj = readClusterByUDomNameIdx( S_System );
			if( clusterObj == NULL ) {
				clusterObj = readClusterByUDomNameIdx( S_System, true );
				if( clusterObj == NULL ) {
					clusterObj = newInstance();
					I$SecSchemaName$ClusterEditObj* clusterEdit = clusterObj-&gt;beginEdit();
					clusterEdit-&gt;setRequiredFullDomName( S_System );
					clusterEdit-&gt;setRequiredDescription( S_System );
					clusterObj = clusterEdit-&gt;create();
				}
			}
			if( transactionStarted ) {
				schema-&gt;commit();
			}
		}
		catch( std::exception&amp; e ) {
			if( transactionStarted ) {
				try {
					schema-&gt;rollback();
				}
				catch( ... ) {
				}
			}
			throw e;
		}
		return( clusterObj );
	}
</CPlusTableObjImplementation>

		<CSharpTableObjInterface>
	virtual I$SecSchemaName$ClusterObj* getSystemCluster();
</CSharpTableObjInterface>

		<CSharpTableObjImplementation>
	I$SecSchemaName$ClusterObj* $SchemaName$$TableName$TableObj::getSystemCluster() {
		static const std::string S_System( "system" );
		bool transactionStarted = schema-&gt;beginTransaction();
		I$SecSchemaName$ClusterObj* clusterObj;
		try {
			clusterObj = readClusterByUDomNameIdx( S_System );
			if( clusterObj == NULL ) {
				clusterObj = readClusterByUDomNameIdx( S_System, true );
				if( clusterObj == NULL ) {
					clusterObj = newInstance();
					I$SecSchemaName$ClusterEditObj* clusterEdit = clusterObj-&gt;beginEdit();
					clusterEdit-&gt;setRequiredFullDomName( S_System );
					clusterEdit-&gt;setRequiredDescription( S_System );
					clusterObj = clusterEdit-&gt;create();
				}
			}
			if( transactionStarted ) {
				schema-&gt;commit();
			}
		}
		catch( std::exception&amp; e ) {
			if( transactionStarted ) {
				try {
					schema-&gt;rollback();
				}
				catch( ... ) {
				}
			}
			throw e;
		}
		return( clusterObj );
	}
</CSharpTableObjImplementation>
	</Table>

	<Id64Gen Name="HostNodeIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Cluster"
			Slice="1010"
			BlockSize="1" />

	<Id32Gen Name="SecAppIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Cluster"
			Slice="1011"
			BlockSize="1" />

	<Id32Gen Name="SecFormIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Cluster"
			Slice="1012"
			BlockSize="1" />

	<Id64Gen Name="SecGroupFormIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Cluster"
			Slice="1013"
			BlockSize="1" />

	<Id32Gen Name="SecGroupIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Cluster"
			Slice="1014"
			BlockSize="1" />

	<Id64Gen Name="SecGrpIncIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Cluster"
			Slice="1015"
			BlockSize="1" />

	<Id64Gen Name="SecGrpMembIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Cluster"
			Slice="1016"
			BlockSize="1" />

	<Table Name="HostNode"
			TableClassCode="a902"
			DbName="HostNode"
			Label="Host Node"
			Description="An installation cluster usually has many nodes"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			LookupIndex="HostNodeUHostNameIdx"
			LoaderBehaviour="Update"
			SecScope="Cluster" >
		<TableCol Name="ClusterId"
				Label="Cluster Id"
				IsNullable="false"
				DataType="ClusterIdGen" />
		<TableCol Name="HostNodeId"
				Label="Host Node Id"
				IsNullable="false"
				GenerateId="true"
				DataType="HostNodeIdGen" />
		<StringCol Name="Description"
				Label="Description"
				IsNullable="false"
				MaxLen="255"
				InitValue="" />
		<StringCol Name="HostName"
				Label="Host Name"
				IsNullable="false"
				MaxLen="192"
				InitValue="" />
		<PrimaryIndex Name="HostNodeIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="HostNode_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="HostNodeId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="HostNodeClusterIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="HostNode_xcluster"
				ShortName="Clus"
				Suffix="ClusterIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
		</Index>
		<Index Name="HostNodeUDescrIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="HostNode_xudsc"
				ShortName="UDescr"
				Suffix="UDescrIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="Description" IsAscending="true" />
		</Index>
		<Index Name="HostNodeUHostNameIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="HostNode_xhnm"
				ShortName="HostNm"
				Suffix="HostNameIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="HostName" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="SecApp"
			TableClassCode="a903"
			DbName="SecApp"
			Label="Security Application"
			Description="Each application has a particular JEE mount point on each node providing service"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			LookupIndex="SecAppUJEEMountIdx"
			LoaderBehaviour="Update"
			SecScope="Cluster" >
		<TableCol Name="ClusterId"
				Label="Cluster Id"
				IsNullable="false"
				DataType="ClusterIdGen" />
		<TableCol Name="SecAppId"
				Label="Security Application Id"
				IsNullable="false"
				GenerateId="true"
				DataType="SecAppIdGen" />
		<StringCol Name="JEEMountName"
				Label="JEE Mount Name"
				IsNullable="false"
				MaxLen="192"
				InitValue="" />
		<PrimaryIndex Name="SecAppIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecApp_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecAppId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="SecAppClusterIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecApp_xcluster"
				ShortName="Clus"
				Suffix="ClusterIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
		</Index>
		<Index Name="SecAppUJEEMountIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecApp_xujeemnt"
				ShortName="JEEMnt"
				Suffix="UJEEMountIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="JEEMountName" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="SecDevice"
			TableClassCode="a905"
			DbName="SecDev"
			Label="Security Device"
			Description="User device security configuration"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			LookupIndex="SecDeviceNameIdx"
			LoaderBehaviour="Insert"
			SecScope="System" >
		<TableCol Name="SecUserId"
				Label="Security User Id"
				IsNullable="false"
				DataType="SecUserIdGen" />
		<TableCol Name="DevName"
				Label="Device Name"
				IsNullable="false"
				DataType="DeviceName" />
		<TextCol Name="PubKey"
				Label="Device Public Key"
				IsNullable="true"
				MaxLen="10000"
				/>
		<PrimaryIndex Name="SecDeviceIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecDev_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="SecUserId" IsAscending="true" />
			<IndexCol Name="DevName" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="SecDeviceNameIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecDev_nameidx"
				ShortName="NameIdx"
				Suffix="NameIdx" >
			<IndexCol Name="SecUserId" IsAscending="true" />
			<IndexCol Name="DevName" IsAscending="true" />
		</Index>
		<Index Name="SecDeviceUserIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecDev_usridx"
				ShortName="UserIdx"
				Suffix="UserIdx" >
			<IndexCol Name="SecUserId" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="SecForm"
			TableClassCode="a906"
			DbName="SecForm"
			Label="Security Form"
			Description="Each form has a JEE servlet mapping name under the application mount point"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			LookupIndex="SecFormUJEEServletIdx"
			LoaderBehaviour="Update"
			SecScope="Cluster" >
		<TableCol Name="ClusterId"
				Label="Cluster Id"
				IsNullable="false"
				DataType="ClusterIdGen" />
		<TableCol Name="SecFormId"
				Label="Security Form Id"
				IsNullable="false"
				GenerateId="true"
				DataType="SecFormIdGen" />
		<TableCol Name="SecAppId"
				Label="Security Application Id"
				IsNullable="false"
				DataType="SecAppIdGen" />
		<StringCol Name="JEEServletMapName"
				Label="JEE Servlet Map Name"
				IsNullable="false"
				MaxLen="192"
				InitValue="" />
		<PrimaryIndex Name="SecFormIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecForm_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecFormId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="SecFormClusterIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecForm_xcluster"
				ShortName="Clus"
				Suffix="ClusterIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
		</Index>
		<Index Name="SecFormSecAppIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecForm_xsecapp"
				ShortName="SecApp"
				Suffix="SecAppIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecAppId" IsAscending="true" />
		</Index>
		<Index Name="SecFormUJEEServletIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecForm_xujeesvlt"
				ShortName="JEEServlet"
				Suffix="UJEEServletIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecAppId" IsAscending="true" />
			<IndexCol Name="JEEServletMapName" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="SecGroup"
			TableClassCode="a909"
			DbName="SecGrp"
			ShortName="Group"
			Label="Security Group"
			Description="Security groups in a cluster configuration gather user members, sub-groups, and form access grants"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			LookupIndex="SecGroupUNameIdx"
			LoaderBehaviour="Insert"
			SecScope="Cluster" >
		<TableCol Name="ClusterId"
				Label="Cluster Id"
				IsNullable="false"
				DataType="ClusterIdGen" />
		<TableCol Name="SecGroupId"
				Label="Security Group Id"
				IsNullable="false"
				GenerateId="true"
				DataType="SecGroupIdGen" />
		<StringCol Name="Name"
				Label="Name"
				IsNullable="false"
				DbName="safe_name"
				MaxLen="64"
				InitValue="" />
		<BoolCol Name="IsVisible"
				IsNullable="false"
				InitValue="false" />
		<PrimaryIndex Name="SecGroupIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecGroup_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecGroupId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="SecGroupClusterIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecGroup_xcluster"
				ShortName="Clus"
				Suffix="ClusterIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
		</Index>
		<Index Name="SecGroupClusterVisIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecGroup_xclustervis"
				ShortName="ClusVis"
				Suffix="ClusterVisIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="IsVisible" IsAscending="true" />
		</Index>
		<Index Name="SecGroupUNameIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecGroup_xuname"
				ShortName="UName"
				Suffix="UNameIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="Name" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="SecGroupForm"
			TableClassCode="a90a"
			DbName="SecGrpFrm"
			ShortName="GroupForm"
			Label="Security Group Form"
			Description="Security group form existence grants members of the group access to the specified form"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			AltIndex="SecGroupFormUFormIdx"
			LoaderBehaviour="Insert"
			SecScope="Cluster" >
		<TableCol Name="ClusterId"
				Label="Cluster Id"
				IsNullable="false"
				DbName="ClusId"
				DataType="ClusterIdGen" />
		<TableCol Name="SecGroupFormId"
				Label="Security Group Form Id"
				IsNullable="false"
				GenerateId="true"
				DbName="SecGrpFrmId"
				DataType="SecGroupFormIdGen" />
		<TableCol Name="SecGroupId"
				Label="Security Group Id"
				IsNullable="false"
				DbName="SecGrpId"
				DataType="SecGroupIdGen" />
		<TableCol Name="SecAppId"
				Label="Security Application Id"
				IsNullable="false"
				DataType="SecAppIdGen" />
		<TableCol Name="SecFormId"
				Label="Security Form Id"
				IsNullable="false"
				DbName="SecFrmId"
				DataType="SecFormIdGen" />
		<PrimaryIndex Name="SecGroupFormIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecGroupForm_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecGroupFormId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="SecGroupFormClusterIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecGroupForm_xcluster"
				ShortName="Clus"
				Suffix="ClusterIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
		</Index>
		<Index Name="SecGroupFormGroupIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecGroupForm_xgroup"
				ShortName="Group"
				Suffix="GroupIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecGroupId" IsAscending="true" />
		</Index>
		<Index Name="SecGroupFormAppIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecGroupForm_xapp"
				ShortName="App"
				Suffix="AppIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecAppId" IsAscending="true" />
		</Index>
		<Index Name="SecGroupFormFormIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecGroupForm_xform"
				ShortName="Form"
				Suffix="FormIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecFormId" IsAscending="true" />
		</Index>
		<Index Name="SecGroupFormUFormIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecGroupForm_xuform"
				ShortName="UForm"
				Suffix="UFormIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecGroupId" IsAscending="true" />
			<IndexCol Name="SecFormId" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="SecGrpInc"
			TableClassCode="a90b"
			DbName="SecInc"
			ShortName="GrpInc"
			Label="Security Group Include"
			Description="Security groups can include other groups"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			AltIndex="SecGrpIncUIncludeIdx"
			LoaderBehaviour="Insert"
			SecScope="Cluster" >
		<TableCol Name="ClusterId"
				Label="Cluster Id"
				IsNullable="false"
				DbName="ClusId"
				DataType="ClusterIdGen" />
		<TableCol Name="SecGrpIncId"
				Label="Security Group Include Id"
				IsNullable="false"
				GenerateId="true"
				DbName="SecGrpIncId"
				DataType="SecGrpIncIdGen" />
		<TableCol Name="SecGroupId"
				Label="Security Group Id"
				IsNullable="false"
				DbName="SecGrpId"
				DataType="SecGroupIdGen" />
		<TableCol Name="IncludeGroupId"
				Label="Include Security Group Id"
				IsNullable="false"
				DbName="IncGrpId"
				DataType="SecGroupIdGen" />
		<PrimaryIndex Name="SecGrpIncIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecInclude_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecGrpIncId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="SecGrpIncClusterIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecInclude_xcluster"
				ShortName="Clus"
				Suffix="ClusterIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
		</Index>
		<Index Name="SecGrpIncGroupIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecInclude_xgroup"
				ShortName="Group"
				Suffix="GroupIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecGroupId" IsAscending="true" />
		</Index>
		<Index Name="SecGrpIncIncludeIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecInclude_xinc"
				ShortName="Include"
				Suffix="IncludeIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="IncludeGroupId" IsAscending="true" />
		</Index>
		<Index Name="SecGrpIncUIncludeIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecInclude_xuinc"
				ShortName="UInclude"
				Suffix="UIncludeIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecGroupId" IsAscending="true" />
			<IndexCol Name="IncludeGroupId" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="SecGrpMemb"
			TableClassCode="a90c"
			DbName="SecMemb"
			ShortName="GrpMemb"
			Label="Security Group Member"
			Description="Security group members tie the SecUser to specific groups"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			AltIndex="SecGrpMembUUserIdx"
			LoaderBehaviour="Insert"
			SecScope="Cluster" >
		<TableCol Name="ClusterId"
				Label="Cluster Id"
				IsNullable="false"
				DataType="ClusterIdGen" />
		<TableCol Name="SecGrpMembId"
				Label="Security Group Member Id"
				IsNullable="false"
				GenerateId="true"
				DataType="SecGrpMembIdGen" />
		<TableCol Name="SecGroupId"
				Label="Security Group Id"
				IsNullable="false"
				DataType="SecGroupIdGen" />
		<TableCol Name="SecUserId"
				Label="Security User Id"
				IsNullable="false"
				DataType="SecUserIdGen" />
		<PrimaryIndex Name="SecGrpMembIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecMember_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecGrpMembId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="SecGrpMembClusterIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecMember_xcluster"
				ShortName="Clus"
				Suffix="ClusterIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
		</Index>
		<Index Name="SecGrpMembGroupIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecMember_xgroup"
				ShortName="Group"
				Suffix="GroupIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecGroupId" IsAscending="true" />
		</Index>
		<Index Name="SecGrpMembUserIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecMember_xuser"
				ShortName="User"
				Suffix="UserIdx" >
			<IndexCol Name="SecUserId" IsAscending="true" />
		</Index>
		<Index Name="SecGrpMembUUserIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecMember_xuuser"
				ShortName="UUser"
				Suffix="UUserIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="SecGroupId" IsAscending="true" />
			<IndexCol Name="SecUserId" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="SecSession"
			TableClassCode="a90d"
			DbName="SecSess"
			ShortName="Sess"
			Label="Security Session"
			Description="Security sessions are valid throughout the cluster"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			PageData="true"
			LoaderBehaviour="Insert"
			SecScope="System" >
		<TableCol Name="SecSessionId"
				Label="Security Session Id"
				IsNullable="false"
				GenerateId="true"
				DataType="SecSessionIdGen" />
		<TableCol Name="SecUserId"
				Label="Security User Id"
				IsNullable="false"
				DataType="SecUserIdGen" />
		<TableCol Name="SecDevName"
				Label="Sesion Device Name"
				IsNullable="true"
				DbName="SecDevName"
				DataType="DeviceName" />
		<TimestampCol Name="Start"
				IsNullable="false"
				DbName="start_ts" />
		<TimestampCol Name="Finish"
				IsNullable="true"
				DbName="finish_ts" />
		<TableCol Name="SecProxyId"
				Label="Security Proxy User Id"
				IsNullable="true"
				DataType="SecUserIdGen" />
		<PrimaryIndex Name="SecSessionIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="Session_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="SecSessionId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="SessionSecUserIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="Session_xsecuser"
				ShortName="SecUsr"
				Suffix="SecUserIdx" >
			<IndexCol Name="SecUserId" IsAscending="true" />
		</Index>
		<Index Name="SessionSecDevIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="Session_xsecdev"
				ShortName="SecDev"
				Suffix="SecDevIdx" >
			<IndexCol Name="SecUserId" IsAscending="true" />
			<IndexCol Name="SecDevName" IsAscending="true" />
		</Index>
		<Index Name="SessionStartIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="Session_xstart"
				ShortName="Start"
				Suffix="StartIdx" >
			<IndexCol Name="SecUserId" IsAscending="true" />
			<IndexCol Name="Start" IsAscending="true" />
		</Index>
		<Index Name="SessionFinishIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="Session_xfnsh"
				ShortName="Finish"
				Suffix="FinishIdx" >
			<IndexCol Name="SecUserId" IsAscending="true" />
			<IndexCol Name="Finish" IsAscending="true" />
		</Index>
		<Index Name="SessionSecProxyIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="Session_xproxy"
				ShortName="SecProxy"
				Suffix="SecProxyIdx" >
			<IndexCol Name="SecProxyId" IsAscending="true" />
		</Index>

		<CafeTableObjInterface>
	I$SecSchemaName$SecSessionObj getSystemSession();
</CafeTableObjInterface>

		<CafeTableObjImplementation>
	public I$SecSchemaName$SecSessionObj getSystemSession() {
		boolean transactionStarted = schema.beginTransaction();
		I$SecSchemaName$SecUserObj userObj;
		I$SecSchemaName$SecSessionObj sessionObj;
		try {
			userObj = schema.getSecUserTableObj().getSystemUser();
			sessionObj = readSecSessionByStartIdx( userObj.getRequiredSecUserId(),
				Calendar.getInstance() );
			if( sessionObj == null ) {
				sessionObj = newInstance();
				I$SecSchemaName$SecSessionEditObj sessionEdit = sessionObj.beginEdit();
				sessionEdit.setRequiredContainerSecUser( userObj );
				sessionEdit.setRequiredStart( Calendar.getInstance() );
				sessionEdit.setOptionalFinish( null );
				sessionObj = sessionEdit.create();
			}
			if( transactionStarted ) {
				schema.commit();
			}
		}
		catch( RuntimeException e ) {
			if( transactionStarted ) {
				try {
					schema.rollback();
				}
				catch( Exception e2 ) {
				}
			}
			throw e;
		}
		return( sessionObj );
	}
</CafeTableObjImplementation>

		<HPlusTableObjInterface>
	virtual I$SecSchemaName$SecSessionObj* getSystemSession() = 0;
</HPlusTableObjInterface>

		<CPlusTableObjInterface>
	virtual I$SecSchemaName$SecSessionObj* getSystemSession();
</CPlusTableObjInterface>

		<CPlusTableObjImplementation>
	static I$SecSchemaName$SecSessionObj* S_systemSession = NULL;

	I$SecSchemaName$SecSessionObj* $SchemaName$$TableName$TableObj::getSystemSession() {
		static const std::string S_ProcName( "getSystemSession" );
		static const std::string S_UserObj( "userObj" );
		bool transactionStarted = schema-&gt;beginTransaction();
		I$SecSchemaName$SecUserObj* userObj;
		I$SecSchemaName$SecSessionObj* sessionObj = S_systemSession;
		try {
			std::chrono::system_clock::time_point* ts = cflib::CFLib::getUTCTimestamp();
			userObj = schema-&gt;getSecUserTableObj()-&gt;getSystemUser();
			if( userObj == NULL ) {
				throw cflib::CFLibNullArgumentException( CLASS_NAME,
					S_ProcName,
					0,
					S_UserObj );
			}
			if( sessionObj == NULL ) {
				sessionObj = readSecSessionByStartIdx( userObj-&gt;getRequiredSecUserId(),
					*ts,
					true );
				if( sessionObj == NULL ) {
					sessionObj = newInstance();
					I$SecSchemaName$SecSessionEditObj* sessionEdit = sessionObj-&gt;beginEdit();
					sessionEdit-&gt;setRequiredContainerSecUser( userObj );
					sessionEdit-&gt;setRequiredStart( *ts );
					sessionEdit-&gt;setOptionalFinishNull();
					sessionObj = sessionEdit-&gt;create();
					S_systemSession = sessionObj;
				}
			}
			if( transactionStarted ) {
				schema-&gt;commit();
			}
			delete ts;
			ts = NULL;
		}
		catch( std::exception&amp; e ) {
			if( transactionStarted ) {
				try {
					schema-&gt;rollback();
				}
				catch( ... ) {
				}
			}
			throw e;
		}
		return( sessionObj );
	}
</CPlusTableObjImplementation>

		<CSharpTableObjInterface>
	virtual I$SecSchemaName$SecSessionObj* getSystemSession();
</CSharpTableObjInterface>

		<CSharpTableObjImplementation>
	static I$SecSchemaName$SecSessionObj* S_systemSession = NULL;

	I$SecSchemaName$SecSessionObj* $SchemaName$$TableName$TableObj::getSystemSession() {
		static const std::string S_ProcName( "getSystemSession" );
		static const std::string S_UserObj( "userObj" );
		bool transactionStarted = schema-&gt;beginTransaction();
		I$SecSchemaName$SecUserObj* userObj;
		I$SecSchemaName$SecSessionObj* sessionObj = S_systemSession;
		try {
			std::chrono::system_clock::time_point* ts = cflib::CFLib::getUTCTimestamp();
			userObj = schema-&gt;getSecUserTableObj()-&gt;getSystemUser();
			if( userObj == NULL ) {
				throw cflib::CFLibNullArgumentException( CLASS_NAME,
					S_ProcName,
					0,
					S_UserObj );
			}
			if( sessionObj == NULL ) {
				sessionObj = readSecSessionByStartIdx( userObj-&gt;getRequiredSecUserId(),
					*ts,
					true );
				if( sessionObj == NULL ) {
					sessionObj = newInstance();
					I$SecSchemaName$SecSessionEditObj* sessionEdit = sessionObj-&gt;beginEdit();
					sessionEdit-&gt;setRequiredContainerSecUser( userObj );
					sessionEdit-&gt;setRequiredStart( *ts );
					sessionEdit-&gt;setOptionalFinishNull();
					sessionObj = sessionEdit-&gt;create();
					S_systemSession = sessionObj;
				}
			}
			if( transactionStarted ) {
				schema-&gt;commit();
			}
			delete ts;
			ts = NULL;
		}
		catch( std::exception&amp; e ) {
			if( transactionStarted ) {
				try {
					schema-&gt;rollback();
				}
				catch( ... ) {
				}
			}
			throw e;
		}
		return( sessionObj );
	}
</CSharpTableObjImplementation>
	</Table>

	<Table Name="SecUser"
			TableClassCode="a90e"
			DbName="SecUser"
			Label="Security User"
			Description="Login and security information is global amongst the clusters"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			LookupIndex="SecUserLoginIdx"
			LoaderBehaviour="Insert"
			SecScope="System" >
		<TableCol Name="SecUserId"
				Label="Security User Id"
				IsNullable="false"
				GenerateId="true"
				DataType="SecUserIdGen" />
		<StringCol Name="LoginId"
				Label="Login Id"
				IsNullable="false"
				DbName="login_id"
				MaxLen="32"
				InitValue="" />
		<StringCol Name="EMailAddress"
				Label="EMail Address"
				IsNullable="false"
				DbName="email_addr"
				MaxLen="192"
				InitValue="" />
		<UuidCol Name="EMailConfirmUuid"
				Label="EMail Confirm UUID"
				IsNullable="true"
				DbName="em_confuuid" />
		<TableCol Name="DfltDevUserId"
				Label="Default Device Security User Id"
				IsNullable="true"
				DbName="DefDevUserId"
				DataType="SecUserIdGen" />
		<TableCol Name="DfltDevName"
				Label="Default Device Name"
				IsNullable="true"
				DbName="DefDevName"
				DataType="DeviceName" />
		<TableCol Name="PasswordHash"
				Label="Password Hash"
				IsNullable="false"
				DbName="pwd_hash"
				DataType="SHA512HexHash" />
		<UuidCol Name="PasswordResetUuid"
				Label="Password Reset UUID"
				IsNullable="true"
				DbName="pwdrstuuid" />
		<PrimaryIndex Name="SecUserIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecUser_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="SecUserId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="SecUserLoginIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="SecUser_xulogin"
				ShortName="ULogin"
				Suffix="ULoginIdx" >
			<IndexCol Name="LoginId" IsAscending="true" />
		</Index>
		<Index Name="SecUserUEMailConfirmIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecUser_xemconf"
				ShortName="EMailConf"
				Suffix="EMConfIdx" >
			<IndexCol Name="EMailConfirmUuid" IsAscending="true" />
		</Index>
		<Index Name="SecUserPasswordResetIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecUser_xpwdrst"
				ShortName="PwdReset"
				Suffix="PwdResetIdx" >
			<IndexCol Name="PasswordResetUuid" IsAscending="true" />
		</Index>
		<Index Name="SecUserDefDevIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="SecUser_defdevidx"
				ShortName="DefDevIdx"
				Suffix="DefDevIdx" >
			<IndexCol Name="DfltDevUserId" IsAscending="true" />
			<IndexCol Name="DfltDevName" IsAscending="true" />
		</Index>

		<CafeTableObjInterface>
	I$SecSchemaName$SecUserObj getSystemUser();
</CafeTableObjInterface>

		<CafeTableObjImplementation>
	public I$SecSchemaName$SecUserObj getSystemUser() {
		boolean transactionStarted = schema.beginTransaction();
		I$SecSchemaName$SecUserObj secUserObj;
		try {
			secUserObj = schema.getSecUserTableObj().readSecUserByULoginIdx( &quot;system&quot; );
			if( secUserObj == null ) {
				secUserObj = newInstance();
				I$SecSchemaName$SecUserEditObj secUserEdit = secUserObj.beginEdit();
				secUserEdit.setRequiredEMailAddress( &quot;system&quot; );
				secUserObj = secUserEdit.create();
			}
			if( transactionStarted ) {
				schema.commit();
			}
		}
		catch( RuntimeException e ) {
			if( transactionStarted ) {
				try {
					schema.rollback();
				}
				catch( Exception e2 ) {
				}
			}
			throw e;
		}
		return( secUserObj );
	}
</CafeTableObjImplementation>

		<HPlusTableObjInterface>
	virtual I$SecSchemaName$SecUserObj* getSystemUser() = 0;
</HPlusTableObjInterface>

		<CPlusTableObjInterface>
	virtual I$SecSchemaName$SecUserObj* getSystemUser();
</CPlusTableObjInterface>

		<CPlusTableObjImplementation>
	I$SecSchemaName$SecUserObj* $SchemaName$$TableName$TableObj::getSystemUser() {
		static const std::string S_System( "system" );
		bool transactionStarted = schema-&gt;beginTransaction();
		I$SecSchemaName$SecUserObj* secUserObj;
		try {
			secUserObj = schema-&gt;getSecUserTableObj()-&gt;readSecUserByULoginIdx( S_System );
			if( secUserObj == NULL ) {
				secUserObj = schema-&gt;getSecUserTableObj()-&gt;readSecUserByULoginIdx( S_System, true );
				if( secUserObj == NULL ) {
					secUserObj = newInstance();
					I$SecSchemaName$SecUserEditObj* secUserEdit = secUserObj-&gt;beginEdit();
					secUserEdit-&gt;setRequiredEMailAddress( S_System );
					secUserObj = secUserEdit-&gt;create();
				}
			}
			if( transactionStarted ) {
				schema-&gt;commit();
			}
		}
		catch( std::exception&amp; e ) {
			if( transactionStarted ) {
				try {
					schema-&gt;rollback();
				}
				catch( ... ) {
				}
			}
			throw e;
		}
		return( secUserObj );
	}
</CPlusTableObjImplementation>

		<CSharpTableObjInterface>
	virtual I$SecSchemaName$SecUserObj* getSystemUser();
</CSharpTableObjInterface>

		<CSharpTableObjImplementation>
	I$SecSchemaName$SecUserObj* $SchemaName$$TableName$TableObj::getSystemUser() {
		static const std::string S_System( "system" );
		bool transactionStarted = schema-&gt;beginTransaction();
		I$SecSchemaName$SecUserObj* secUserObj;
		try {
			secUserObj = schema-&gt;getSecUserTableObj()-&gt;readSecUserByULoginIdx( S_System );
			if( secUserObj == NULL ) {
				secUserObj = schema-&gt;getSecUserTableObj()-&gt;readSecUserByULoginIdx( S_System, true );
				if( secUserObj == NULL ) {
					secUserObj = newInstance();
					I$SecSchemaName$SecUserEditObj* secUserEdit = secUserObj-&gt;beginEdit();
					secUserEdit-&gt;setRequiredEMailAddress( S_System );
					secUserObj = secUserEdit-&gt;create();
				}
			}
			if( transactionStarted ) {
				schema-&gt;commit();
			}
		}
		catch( std::exception&amp; e ) {
			if( transactionStarted ) {
				try {
					schema-&gt;rollback();
				}
				catch( ... ) {
				}
			}
			throw e;
		}
		return( secUserObj );
	}
</CSharpTableObjImplementation>
	</Table>

	<Table Name="SysCluster"
			TableClassCode="a90f"
			DbName="sysclus"
			ShortName="SysClus"
			Label="Cluster"
			Description="A Cluster is an MSS Code Factory installation"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Insert"
			SecScope="System" >
		<Int32Col Name="SingletonId"
				Label="Singleton"
				IsNullable="false"
				DbName="sgltn_id"
				MinValue="1"
				MaxValue="1"
				InitValue="1" />
		<TableCol Name="ClusterId"
				IsNullable="false"
				DbName="sys_clus_id"
				DataType="ClusterIdGen" />
		<PrimaryIndex Name="SysClusterIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="syscluster_pk"
				ShortName="PIdx"
				Suffix="IdIdx"
				Label="IdIdx" >
			<IndexCol Name="SingletonId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="SysClusterClusterIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="sysclus_xclus"
				ShortName="ClusIdx"
				Suffix="ClusterIdx"
				Label="Cluster Index" >
			<IndexCol Name="ClusterId" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="Tenant"
			TableClassCode="a910"
			DbName="tenant"
			ShortName="Tenant"
			Label="Tenant"
			Description="A Cluster can have any number of Tenants"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			LookupIndex="TenantUNameIdx"
			LoaderBehaviour="Insert"
			SecScope="System" >
		<TableCol Name="ClusterId"
				IsNullable="false"
				DataType="ClusterIdGen" />
		<TableCol Name="Id"
				IsNullable="false"
				GenerateId="true"
				DataType="TenantIdGen" />
		<StringCol Name="TenantName"
				IsNullable="false"
				MaxLen="192"
				InitValue="" />
		<PrimaryIndex Name="TenantIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="tenant_pk"
				ShortName="PIdx"
				Suffix="IdIdx"
				Label="IdIdx" >
			<IndexCol Name="Id" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="TenantClusterIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="tenant_xcluster"
				ShortName="Clus"
				Suffix="ClusterIdx"
				Label="ClusterIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
		</Index>
		<Index Name="TenantUNameIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="tenant_xuname"
				ShortName="UName"
				Suffix="UNameIdx"
				Label="UNameIdx" >
			<IndexCol Name="ClusterId" IsAscending="true" />
			<IndexCol Name="TenantName" IsAscending="true" />
		</Index>

		<CafeTableObjInterface>
	I$SecSchemaName$TenantObj getSystemTenant();
</CafeTableObjInterface>

		<CafeTableObjImplementation>
	public I$SecSchemaName$TenantObj getSystemTenant() {
		boolean transactionStarted = schema.beginTransaction();
		I$SecSchemaName$TenantObj tenantObj;
		try {
			I$SecSchemaName$ClusterObj clusterObj = schema.getClusterTableObj().getSystemCluster();
			tenantObj = readTenantByUNameIdx( clusterObj.getRequiredId(), &quot;system&quot; );
			if( tenantObj == null ) {
				tenantObj = newInstance();
				I$SecSchemaName$TenantEditObj tenantEdit = tenantObj.beginEdit();
				tenantEdit.setRequiredContainerCluster( clusterObj );
				tenantEdit.setRequiredTenantName( &quot;system&quot; );
				tenantObj = tenantEdit.create();
			}
			if( transactionStarted ) {
				schema.commit();
			}
		}
		catch( RuntimeException e ) {
			if( transactionStarted ) {
				try {
					schema.rollback();
				}
				catch( Exception e2 ) {
				}
			}
			throw e;
		}
		return( tenantObj );
	}
</CafeTableObjImplementation>

		<HPlusTableObjInterface>
	virtual I$SecSchemaName$TenantObj* getSystemTenant() = 0;
</HPlusTableObjInterface>

		<CPlusTableObjInterface>
	virtual I$SecSchemaName$TenantObj* getSystemTenant();
</CPlusTableObjInterface>

		<CPlusTableObjImplementation>
	I$SecSchemaName$TenantObj* $SchemaName$$TableName$TableObj::getSystemTenant() {
		static const std::string S_System( "system" );
		bool transactionStarted = schema-&gt;beginTransaction();
		I$SecSchemaName$TenantObj* tenantObj;
		try {
			I$SecSchemaName$ClusterObj* clusterObj = schema-&gt;getClusterTableObj()-&gt;getSystemCluster();
			tenantObj = readTenantByUNameIdx( clusterObj-&gt;getRequiredId(), S_System );
			if( tenantObj == NULL ) {
				tenantObj = readTenantByUNameIdx( clusterObj-&gt;getRequiredId(), S_System, true );
				if( tenantObj == NULL ) {
					tenantObj = newInstance();
					I$SecSchemaName$TenantEditObj* tenantEdit = tenantObj-&gt;beginEdit();
					tenantEdit-&gt;setRequiredContainerCluster( clusterObj );
					tenantEdit-&gt;setRequiredTenantName( S_System );
					tenantObj = tenantEdit-&gt;create();
				}
			}
			if( transactionStarted ) {
				schema-&gt;commit();
			}
		}
		catch( std::exception&amp; e ) {
			if( transactionStarted ) {
				try {
					schema-&gt;rollback();
				}
				catch( ... ) {
				}
			}
			throw e;
		}
		return( tenantObj );
	}
</CPlusTableObjImplementation>

		<CSharpTableObjInterface>
	virtual I$SecSchemaName$TenantObj* getSystemTenant();
</CSharpTableObjInterface>

		<CSharpTableObjImplementation>
	I$SecSchemaName$TenantObj* $SchemaName$$TableName$TableObj::getSystemTenant() {
		static const std::string S_System( "system" );
		bool transactionStarted = schema-&gt;beginTransaction();
		I$SecSchemaName$TenantObj* tenantObj;
		try {
			I$SecSchemaName$ClusterObj* clusterObj = schema-&gt;getClusterTableObj()-&gt;getSystemCluster();
			tenantObj = readTenantByUNameIdx( clusterObj-&gt;getRequiredId(), S_System );
			if( tenantObj == NULL ) {
				tenantObj = readTenantByUNameIdx( clusterObj-&gt;getRequiredId(), S_System, true );
				if( tenantObj == NULL ) {
					tenantObj = newInstance();
					I$SecSchemaName$TenantEditObj* tenantEdit = tenantObj-&gt;beginEdit();
					tenantEdit-&gt;setRequiredContainerCluster( clusterObj );
					tenantEdit-&gt;setRequiredTenantName( S_System );
					tenantObj = tenantEdit-&gt;create();
				}
			}
			if( transactionStarted ) {
				schema-&gt;commit();
			}
		}
		catch( std::exception&amp; e ) {
			if( transactionStarted ) {
				try {
					schema-&gt;rollback();
				}
				catch( ... ) {
				}
			}
			throw e;
		}
		return( tenantObj );
	}
</CSharpTableObjImplementation>
	</Table>

	<Id32Gen Name="TSecGroupIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Tenant"
			Slice="1018"
			BlockSize="1" />

	<Id64Gen Name="TSecGrpIncIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Tenant"
			Slice="1019"
			BlockSize="1" />

	<Id64Gen Name="TSecGrpMembIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Tenant"
			Slice="1020"
			BlockSize="1" />

	<Table Name="TSecGroup"
			TableClassCode="a911"
			DbName="TSecGrp"
			ShortName="TSecGroup"
			Label="Tenant Security Group"
			Description="Tenant Security groups in a tenant gather user members, sub-groups, and form access grants"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			LookupIndex="TSecGroupUNameIdx"
			LoaderBehaviour="Insert"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				Label="Tenant Id"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="TSecGroupId"
				Label="TSecurity Group Id"
				IsNullable="false"
				GenerateId="true"
				DataType="TSecGroupIdGen" />
		<StringCol Name="Name"
				Label="Name"
				IsNullable="false"
				DbName="safe_name"
				MaxLen="64"
				InitValue="" />
		<BoolCol Name="IsVisible"
				IsNullable="false"
				InitValue="false" />
		<PrimaryIndex Name="TSecGroupIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="TSecGroup_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="TSecGroupId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="TSecGroupTenantIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="TSecGroup_xtenant"
				ShortName="Tenant"
				Suffix="TenantIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
		</Index>
		<Index Name="TSecGroupTenantVisIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="TSecGroup_xtenantvis"
				ShortName="TenantVis"
				Suffix="TenantVisIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="IsVisible" IsAscending="true" />
		</Index>
		<Index Name="TSecGroupUNameIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="TSecGroup_xuname"
				ShortName="UName"
				Suffix="UNameIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="Name" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="TSecGrpInc"
			TableClassCode="a912"
			DbName="TSecInc"
			ShortName="TSecGrpInc"
			Label="Tenant Security Group Include"
			Description="Tenant Security groups can include other groups"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			AltIndex="TSecGrpIncUIncludeIdx"
			LoaderBehaviour="Insert"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				Label="Tenant Id"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="TSecGrpIncId"
				Label="TSecurity Group Include Id"
				IsNullable="false"
				GenerateId="true"
				DbName="TSecGrpIncId"
				DataType="TSecGrpIncIdGen" />
		<TableCol Name="TSecGroupId"
				Label="Tenant Security Group Id"
				IsNullable="false"
				DbName="TSecGrpId"
				DataType="TSecGroupIdGen" />
		<TableCol Name="IncludeGroupId"
				Label="Include Tenant Security Group Id"
				IsNullable="false"
				DbName="IncGrpId"
				DataType="TSecGroupIdGen" />
		<PrimaryIndex Name="TSecGrpIncIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="TSecInclude_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="TSecGrpIncId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="TSecGrpIncTenantIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="TSecInclude_xtenant"
				ShortName="Tenant"
				Suffix="TenantIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
		</Index>
		<Index Name="TSecGrpIncGroupIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="TSecInclude_xgroup"
				ShortName="Group"
				Suffix="GroupIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="TSecGroupId" IsAscending="true" />
		</Index>
		<Index Name="TSecGrpIncIncludeIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="TSecInclude_xinc"
				ShortName="Include"
				Suffix="IncludeIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="IncludeGroupId" IsAscending="true" />
		</Index>
		<Index Name="TSecGrpIncUIncludeIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="TSecInclude_xuinc"
				ShortName="UInclude"
				Suffix="UIncludeIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="TSecGroupId" IsAscending="true" />
			<IndexCol Name="IncludeGroupId" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="TSecGrpMemb"
			TableClassCode="a913"
			DbName="TSecMemb"
			ShortName="TSecGrpMemb"
			Label="Tenant Security Group Member"
			Description="Tenant Security group members tie the SecUser to specific groups"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="true"
			PageData="true"
			AltIndex="TSecGrpMembUUserIdx"
			LoaderBehaviour="Insert"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				Label="Tenant Id"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="TSecGrpMembId"
				Label="TSecurity Group Member Id"
				IsNullable="false"
				GenerateId="true"
				DataType="TSecGrpMembIdGen" />
		<TableCol Name="TSecGroupId"
				Label="TSecurity Group Id"
				IsNullable="false"
				DataType="TSecGroupIdGen" />
		<TableCol Name="SecUserId"
				Label="Security User Id"
				IsNullable="false"
				DataType="SecUserIdGen" />
		<PrimaryIndex Name="TSecGrpMembIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="TSecMember_pidx"
				ShortName="PIdx"
				Suffix="IdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="TSecGrpMembId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="TSecGrpMembTenantIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="TSecMember_xtenant"
				ShortName="Tenant"
				Suffix="TenantIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
		</Index>
		<Index Name="TSecGrpMembGroupIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="TSecMember_xgroup"
				ShortName="Group"
				Suffix="GroupIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="TSecGroupId" IsAscending="true" />
		</Index>
		<Index Name="TSecGrpMembUserIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="TSecMember_xuser"
				ShortName="User"
				Suffix="UserIdx" >
			<IndexCol Name="SecUserId" IsAscending="true" />
		</Index>
		<Index Name="TSecGrpMembUUserIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="TSecMember_xuuser"
				ShortName="UUser"
				Suffix="UUserIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="TSecGroupId" IsAscending="true" />
			<IndexCol Name="SecUserId" IsAscending="true" />
		</Index>
	</Table>

	<TableAddendum FromTable="Cluster">
		<Relation Name="ClusterHostNode"
				RelationType="Components"
				DbName="clus_hostnode"
				Label="Host Node"
				Suffix="HostNode"
				FromIndex="ClusterIdIdx"
				ToIndex="HostNode.HostNodeClusterIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="Id" ToCol="ClusterId" />
		</Relation>
		<Relation Name="ClusterTenant"
				RelationType="Components"
				DbName="clus_tenant"
				Label="Tenant"
				Suffix="Tenant"
				FromIndex="ClusterIdIdx"
				ToIndex="Tenant.TenantClusterIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="Id" ToCol="ClusterId" />
		</Relation>
		<Relation Name="ClusterSecApp"
				RelationType="Components"
				DbName="clus_secapp"
				Label="Security Application"
				Suffix="SecApp"
				FromIndex="ClusterIdIdx"
				ToIndex="SecApp.SecAppClusterIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="Id" ToCol="ClusterId" />
		</Relation>
		<Relation Name="ClusterSecGroup"
				RelationType="Components"
				DbName="clus_secgrp"
				Label="Security Group"
				Suffix="SecGroup"
				FromIndex="ClusterIdIdx"
				ToIndex="SecGroup.SecGroupClusterIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="Id" ToCol="ClusterId" />
		</Relation>
		<Relation Name="ClusterSysCluster"
				RelationType="Components"
				DbName="clus_sysclus"
				Label="System Cluster"
				Suffix="SysCluster"
				FromIndex="ClusterIdIdx"
				ToIndex="SysCluster.SysClusterClusterIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="Id" ToCol="ClusterId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="HostNode">
		<Relation Name="HostNodeCluster"
				RelationType="Container"
				DbName="hostnode_clus"
				Label="Cluster"
				Suffix="Cluster"
				FromIndex="HostNodeClusterIdx"
				ToIndex="Cluster.ClusterIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="Id" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="SecApp">
		<Relation Name="SecAppCluster"
				RelationType="Container"
				DbName="secapp_clus"
				Label="Cluster"
				Suffix="Cluster"
				FromIndex="SecAppClusterIdx"
				ToIndex="Cluster.ClusterIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="Id" />
		</Relation>
		<Relation Name="SecAppForm"
				RelationType="Components"
				DbName="secapp_form"
				Label="Security Form"
				Suffix="Form"
				FromIndex="SecAppIdIdx"
				ToIndex="SecForm.SecFormSecAppIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="SecAppId" ToCol="SecAppId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="SecDevice">
		<Relation Name="SecDeviceSecUser"
				RelationType="Container"
				DbName="secdev_secuser"
				Label="Security User"
				Suffix="SecUser"
				FromIndex="SecDeviceUserIdx"
				ToIndex="SecUser.SecUserIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="SecUserId" ToCol="SecUserId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="SecForm">
		<Relation Name="SecFormCluster"
				RelationType="Owner"
				DbName="secform_clus"
				Label="Cluster"
				Suffix="Cluster"
				FromIndex="SecFormClusterIdx"
				ToIndex="Cluster.ClusterIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="Id" />
		</Relation>
		<Relation Name="SecFormApplication"
				RelationType="Container"
				DbName="secform_app"
				Label="Application"
				Suffix="Application"
				FromIndex="SecFormSecAppIdx"
				ToIndex="SecApp.SecAppIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="SecAppId" ToCol="SecAppId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="SecGroup">
		<Relation Name="SecGroupCluster"
				RelationType="Container"
				DbName="secgrp_clus"
				Label="Cluster"
				Suffix="Cluster"
				FromIndex="SecGroupClusterIdx"
				ToIndex="Cluster.ClusterIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="Id" />
		</Relation>
		<Relation Name="SecGrpInc"
				RelationType="Components"
				DbName="secgrp_inc"
				Label="Sub Group"
				Suffix="Include"
				FromIndex="SecGroupIdIdx"
				ToIndex="SecGrpInc.SecGrpIncGroupIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="SecGroupId" ToCol="SecGroupId" />
		</Relation>
		<Relation Name="SecGrpMemb"
				RelationType="Components"
				DbName="secgrp_memb"
				Label="Group Member"
				Suffix="Member"
				FromIndex="SecGroupIdIdx"
				ToIndex="SecGrpMemb.SecGrpMembGroupIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="SecGroupId" ToCol="SecGroupId" />
		</Relation>
		<Relation Name="SecGrpIncByGroup"
				RelationType="Children"
				DbName="secgrp_incbygrp"
				Label="Included By Group"
				Suffix="IncByGroup"
				FromIndex="SecGroupIdIdx"
				ToIndex="SecGrpInc.SecGrpIncIncludeIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="SecGroupId" ToCol="IncludeGroupId" />
		</Relation>
		<Relation Name="SecGroupForm"
				RelationType="Components"
				DbName="secgrp_form"
				Label="Group Form Permission"
				Suffix="Form"
				FromIndex="SecGroupIdIdx"
				ToIndex="SecGroupForm.SecGroupFormGroupIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="SecGroupId" ToCol="SecGroupId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="SecGroupForm">
		<Relation Name="SecGroupFormCluster"
				RelationType="Owner"
				DbName="secgrpfrm_clus"
				Label="Cluster"
				Suffix="Cluster"
				FromIndex="SecGroupFormClusterIdx"
				ToIndex="Cluster.ClusterIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="Id" />
		</Relation>
		<Relation Name="SecGroupFormGroup"
				RelationType="Container"
				DbName="secgrpfrm_grp"
				Label="Group"
				Suffix="Group"
				FromIndex="SecGroupFormGroupIdx"
				ToIndex="SecGroup.SecGroupIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="SecGroupId" ToCol="SecGroupId" />
		</Relation>
		<Relation Name="SecGroupFormApp"
				RelationType="Parent"
				DbName="secgrpfrm_app"
				Label="App"
				Suffix="App"
				FromIndex="SecGroupFormAppIdx"
				ToIndex="SecApp.SecAppIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="SecAppId" ToCol="SecAppId" />
		</Relation>
		<Relation Name="SecGroupFormForm"
				RelationType="Parent"
				DbName="secgrpfrm_frm"
				Label="Form"
				Suffix="Form"
				FromIndex="SecGroupFormFormIdx"
				ToIndex="SecForm.SecFormIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="SecFormId" ToCol="SecFormId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="SecGrpInc">
		<Relation Name="SecGrpIncCluster"
				RelationType="Owner"
				DbName="secgrpinc_clus"
				Label="Cluster"
				Suffix="Cluster"
				FromIndex="SecGrpIncClusterIdx"
				ToIndex="Cluster.ClusterIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="Id" />
		</Relation>
		<Relation Name="SecGrpIncGroup"
				RelationType="Container"
				DbName="secgrpinc_grp"
				Label="Group"
				Suffix="Group"
				FromIndex="SecGrpIncGroupIdx"
				ToIndex="SecGroup.SecGroupIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="SecGroupId" ToCol="SecGroupId" />
		</Relation>
		<Relation Name="SecGrpIncSubGroup"
				RelationType="Parent"
				DbName="secgrpinc_subgrp"
				Label="SubGroup"
				Suffix="SubGroup"
				FromIndex="SecGrpIncIncludeIdx"
				ToIndex="SecGroup.SecGroupIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="IncludeGroupId" ToCol="SecGroupId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="SecGrpMemb">
		<Relation Name="SecGrpMembCluster"
				RelationType="Owner"
				DbName="secgrpmem_clus"
				Label="Cluster"
				Suffix="Cluster"
				FromIndex="SecGrpMembClusterIdx"
				ToIndex="Cluster.ClusterIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="Id" />
		</Relation>
		<Relation Name="SecGrpMembGroup"
				RelationType="Container"
				DbName="secgrpmem_grp"
				Label="Group"
				Suffix="Group"
				FromIndex="SecGrpMembGroupIdx"
				ToIndex="SecGroup.SecGroupIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="ClusterId" />
			<RelationCol Name="SecGroupId" ToCol="SecGroupId" />
		</Relation>
		<Relation Name="SecGrpMembUser"
				RelationType="Parent"
				DbName="secgrpmem_user"
				Label="User"
				Suffix="User"
				FromIndex="SecGrpMembUserIdx"
				ToIndex="SecUser.SecUserIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="SecUserId" ToCol="SecUserId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="SecSession">
		<Relation Name="SecSessionUser"
				RelationType="Container"
				DbName="secsess_user"
				Label="Security User"
				Suffix="SecUser"
				FromIndex="SessionSecUserIdx"
				ToIndex="SecUser.SecUserIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="SecUserId" ToCol="SecUserId" />
		</Relation>
		<Relation Name="SecSessionProxy"
				RelationType="Parent"
				DbName="secsess_proxy"
				Label="Security Proxy User"
				Suffix="SecProxy"
				FromIndex="SessionSecProxyIdx"
				ToIndex="SecUser.SecUserIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="SecProxyId" ToCol="SecUserId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="SecUser">
		<Relation Name="SecUserSecDev"
				RelationType="Components"
				DbName="secuser_secdev"
				Label="Security Device"
				Suffix="SecDev"
				FromIndex="SecUserIdIdx"
				ToIndex="SecDevice.SecDeviceUserIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="SecUserId" ToCol="SecUserId" />
		</Relation>
		<Relation Name="SecUserDefDev"
				RelationType="Lookup"
				DbName="secuser_defdev"
				Label="Default Security Device"
				Suffix="DefDev"
				FromIndex="SecUserDefDevIdx"
				ToIndex="SecDevice.SecDeviceIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="DfltDevUserId" ToCol="SecUserId" />
			<RelationCol Name="DfltDevName" ToCol="DevName" />
		</Relation>
		<Relation Name="SecUserSecSession"
				RelationType="Components"
				DbName="secuser_secsess"
				Label="Security Session"
				Suffix="SecSess"
				FromIndex="SecUserIdIdx"
				ToIndex="SecSession.SessionSecUserIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="SecUserId" ToCol="SecUserId" />
		</Relation>
		<Relation Name="SecUserSecProxySession"
				RelationType="Children"
				DbName="secuser_secproxysess"
				Label="Security Proxy Session"
				Suffix="SecProxy"
				FromIndex="SecUserIdIdx"
				ToIndex="SecSession.SessionSecProxyIdx"
				IsRequired="false"
				 >
			<RelationCol Name="SecUserId" ToCol="SecProxyId" />
		</Relation>
		<Relation Name="SecUserSecGrpMemb"
				RelationType="Children"
				DbName="secuser_secgrpmemb"
				Label="Security Group Members"
				Suffix="SecGrpMemb"
				FromIndex="SecUserIdIdx"
				ToIndex="SecGrpMemb.SecGrpMembUserIdx"
				IsRequired="false"
				 >
			<RelationCol Name="SecUserId" ToCol="SecUserId" />
		</Relation>
		<Relation Name="SecUserTSecGrpMemb"
				RelationType="Children"
				DbName="secuser_tsecgrpmemb"
				Label="Tenant Security Group Members"
				Suffix="TSecGrpMemb"
				FromIndex="SecUserIdIdx"
				ToIndex="TSecGrpMemb.TSecGrpMembUserIdx"
				IsRequired="false"
				 >
			<RelationCol Name="SecUserId" ToCol="SecUserId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="SysCluster">
		<Relation Name="SysClusterCluster"
				RelationType="Container"
				DbName="sysclus_clus"
				Label="Cluster"
				Suffix="Cluster"
				FromIndex="SysClusterClusterIdx"
				ToIndex="Cluster.ClusterIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="Id" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="TSecGroup">
		<Relation Name="TSecGroupTenant"
				RelationType="Container"
				DbName="tsecgrp_tenant"
				Label="Tenant"
				Suffix="Tenant"
				FromIndex="TSecGroupTenantIdx"
				ToIndex="Tenant.TenantIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="Id" />
		</Relation>
		<Relation Name="TSecGrpInc"
				RelationType="Components"
				DbName="tsecgrp_inc"
				Label="Sub Group"
				Suffix="Include"
				FromIndex="TSecGroupIdIdx"
				ToIndex="TSecGrpInc.TSecGrpIncGroupIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="TSecGroupId" ToCol="TSecGroupId" />
		</Relation>
		<Relation Name="TSecGrpMemb"
				RelationType="Components"
				DbName="tsecgrp_memb"
				Label="Group Member"
				Suffix="Member"
				FromIndex="TSecGroupIdIdx"
				ToIndex="TSecGrpMemb.TSecGrpMembGroupIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="TSecGroupId" ToCol="TSecGroupId" />
		</Relation>
		<Relation Name="TSecGrpIncByGroup"
				RelationType="Children"
				DbName="tsecgrp_incbygrp"
				Label="Included By Group"
				Suffix="IncByGroup"
				FromIndex="TSecGroupIdIdx"
				ToIndex="TSecGrpInc.TSecGrpIncIncludeIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="TSecGroupId" ToCol="IncludeGroupId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="TSecGrpInc">
		<Relation Name="TSecGrpIncTenant"
				RelationType="Owner"
				DbName="tsecgrpinc_tenant"
				Label="Tenant"
				Suffix="Tenant"
				FromIndex="TSecGrpIncTenantIdx"
				ToIndex="Tenant.TenantIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="Id" />
		</Relation>
		<Relation Name="TSecGrpIncGroup"
				RelationType="Container"
				DbName="tsecgrpinc_grp"
				Label="Group"
				Suffix="Group"
				FromIndex="TSecGrpIncGroupIdx"
				ToIndex="TSecGroup.TSecGroupIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="TSecGroupId" ToCol="TSecGroupId" />
		</Relation>
		<Relation Name="TSecGrpIncSubGroup"
				RelationType="Parent"
				DbName="tsecgrpinc_subgrp"
				Label="SubGroup"
				Suffix="SubGroup"
				FromIndex="TSecGrpIncIncludeIdx"
				ToIndex="TSecGroup.TSecGroupIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="IncludeGroupId" ToCol="TSecGroupId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="TSecGrpMemb">
		<Relation Name="TSecGrpMembTenant"
				RelationType="Owner"
				DbName="tsecgrpmemb_tenant"
				Label="Tenant"
				Suffix="Tenant"
				FromIndex="TSecGrpMembTenantIdx"
				ToIndex="Tenant.TenantIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="Id" />
		</Relation>
		<Relation Name="TSecGrpMembGroup"
				RelationType="Container"
				DbName="tsecgrpmemb_grp"
				Label="Group"
				Suffix="Group"
				FromIndex="TSecGrpMembGroupIdx"
				ToIndex="TSecGroup.TSecGroupIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="TSecGroupId" ToCol="TSecGroupId" />
		</Relation>
		<Relation Name="TSecGrpMembUser"
				RelationType="Parent"
				DbName="tsecgrpmemb_user"
				Label="User"
				Suffix="User"
				FromIndex="TSecGrpMembUserIdx"
				ToIndex="SecUser.SecUserIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="SecUserId" ToCol="SecUserId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="Tenant">
		<Relation Name="TenantCluster"
				RelationType="Container"
				DbName="tenant_clus"
				Label="Cluster"
				Suffix="Cluster"
				FromIndex="TenantClusterIdx"
				ToIndex="Cluster.ClusterIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ClusterId" ToCol="Id" />
		</Relation>
		<Relation Name="TenantSecGroup"
				RelationType="Components"
				DbName="tenant_secgrp"
				Label="Tenant Security Group"
				Suffix="TSecGroup"
				FromIndex="TenantIdIdx"
				ToIndex="TSecGroup.TSecGroupTenantIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="Id" ToCol="TenantId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="SecUser">
		<ClearDep Name="ClearSecUserDefDev" ClearDepChain="SecUserDefDev" />
	</TableAddendum>

	<TableAddendum FromTable="Cluster">
		<DelDep Name="DelHostNodes" DelDepChain="ClusterHostNode" />
		<DelDep Name="DelTenants" DelDepChain="ClusterTenant" />
		<DelDep Name="DelSecApps" DelDepChain="ClusterSecApp" />
		<DelDep Name="DelSecAppForms" DelDepChain="ClusterSecApp.SecAppForm" />
		<DelDep Name="DelSecGroups" DelDepChain="ClusterSecGroup" />
		<DelDep Name="DelSecGrpIncs" DelDepChain="ClusterSecGroup.SecGrpInc" />
		<DelDep Name="DelSecGrpMembs" DelDepChain="ClusterSecGroup.SecGrpMemb" />
		<DelDep Name="DelSecGrpIncByGroup" DelDepChain="ClusterSecGroup.SecGrpIncByGroup" />
		<DelDep Name="DelSecGroupForms" DelDepChain="ClusterSecGroup.SecGroupForm" />
	</TableAddendum>

	<TableAddendum FromTable="SecApp">
		<DelDep Name="DelSecAppForms" DelDepChain="SecAppForm" />
	</TableAddendum>

	<TableAddendum FromTable="SecGroup">
		<DelDep Name="DelSecGrpIncs" DelDepChain="SecGrpInc" />
		<DelDep Name="DelSecGrpMembs" DelDepChain="SecGrpMemb" />
		<DelDep Name="DelSecGrpIncByGroup" DelDepChain="SecGrpIncByGroup" />
		<DelDep Name="DelSecGroupForms" DelDepChain="SecGroupForm" />
	</TableAddendum>

	<TableAddendum FromTable="SecUser">
		<DelDep Name="DelSecDevices" DelDepChain="SecUserSecDev" />
		<DelDep Name="DelSecProxySessions" DelDepChain="SecUserSecProxySession" />
		<DelDep Name="DelSecSessions" DelDepChain="SecUserSecSession" />
		<DelDep Name="DelSecGrpMembs" DelDepChain="SecUserSecGrpMemb" />
		<DelDep Name="DelTSecGrpMembs" DelDepChain="SecUserTSecGrpMemb" />
	</TableAddendum>

	<TableAddendum FromTable="TSecGroup">
		<DelDep Name="DelGrpIncs" DelDepChain="TSecGrpInc" />
		<DelDep Name="DelGrpMembs" DelDepChain="TSecGrpMemb" />
		<DelDep Name="DelIncludedByGroup" DelDepChain="TSecGrpIncByGroup" />
	</TableAddendum>

	<TableAddendum FromTable="Tenant">
		<DelDep Name="DelTSecGroups" DelDepChain="TenantSecGroup" />
		<DelDep Name="DelGrpIncs" DelDepChain="TenantSecGroup.TSecGrpInc" />
		<DelDep Name="DelGrpMembs" DelDepChain="TenantSecGroup.TSecGrpMemb" />
		<DelDep Name="DelIncludedByGroup" DelDepChain="TenantSecGroup.TSecGrpIncByGroup" />
	</TableAddendum>

	<Id16Gen Name="DefClassIdGen"
			IsNullable="false"
			MinValue="0"
			MaxValue="32767"
			InitValue="0"
			Slice="1021"
			BlockSize="1" />

	<Id64Gen Name="GelCacheIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Tenant"
			Slice="1022"
			BlockSize="1" />

	<Id64Gen Name="GelInstructionIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Tenant"
			Slice="1023"
			BlockSize="1" />

	<Id64Gen Name="GenItemIdGen"
			IsNullable="false"
			MinValue="0"
			MaxValue="2147483647"
			InitValue="0"
			Dispenser="Tenant"
			Slice="1024"
			BlockSize="1" />

	<StringType Name="GenItemNameType"
			IsNullable="false"
			MaxLen="127"
			InitValue="" />

	<Id64Gen Name="RuleCartIdGen"
			IsNullable="false"
			MinValue="0"
			InitValue="0"
			Dispenser="Tenant"
			Slice="1025"
			BlockSize="1" />

	<Id16Gen Name="RuleTypeIdGen"
			IsNullable="false"
			MinValue="0"
			MaxValue="32767"
			InitValue="0"
			Slice="1026"
			BlockSize="1" />

	<Id16Gen Name="ToolIdGen"
			IsNullable="false"
			MinValue="0"
			MaxValue="32767"
			InitValue="0"
			Slice="1027"
			BlockSize="1" />

	<Id16Gen Name="ToolSetIdGen"
			IsNullable="false"
			MinValue="0"
			MaxValue="32767"
			InitValue="0"
			Slice="1028"
			BlockSize="1" />

	<Table Name="DefClass"
			TableClassCode="a914"
			DbName="kbdefclass"
			Label="Definition Class"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LookupIndex="DefClassName"
			LoaderBehaviour="Insert"
			SecScope="None" >
		<TableCol Name="Id"
				IsNullable="false"
				GenerateId="true"
				DataType="DefClassIdGen" />
		<StringCol Name="Name"
				DbName="safe_name"
				IsNullable="false"
				MaxLen="32"
				InitValue="" />
		<TableCol Name="BaseId"
				Label="Base Id"
				IsNullable="true"
				DataType="DefClassIdGen" />
		<PrimaryIndex Name="DefClassIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbdefclass_id"
				Suffix="IdIdx" >
			<IndexCol Name="Id" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="DefClassName"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbdefclass_name"
				Suffix="NameIdx" >
			<IndexCol Name="Name" IsAscending="true" />
		</Index>
		<Index Name="DefClassBaseIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbdefclass_base"
				Suffix="BaseIdx" >
			<IndexCol Name="BaseId" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="GelCache"
			TableClassCode="a915"
			DbName="gelcache"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Insert"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="GEL Cache Id"
				IsNullable="false"
				GenerateId="true"
				DataType="GelCacheIdGen" />
		<StringCol Name="CacheName"
				Label="Cache Name"
				IsNullable="false"
				MaxLen="511"
				InitValue="" />
		<PrimaryIndex Name="GelCacheIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelcache_id"
				Suffix="IdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GelCacheTenantIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelcache_xtent"
				Suffix="TenantIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
		</Index>
		<Index Name="GelCacheAltIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelcache_adx"
				Suffix="AltIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="CacheName" IsAscending="true" />
		</Index>

		<CafeObjMembers>
	protected Map&lt; String, I$SchemaName$GelInstructionObj &gt; mapMacro = new HashMap&lt; String, I$SchemaName$GelInstructionObj &gt;();
	protected Map&lt; String, I$SchemaName$GelExecutableObj &gt; mapExecutable = new HashMap&lt; String, I$SchemaName$GelExecutableObj &gt;();</CafeObjMembers>

		<CafeObjInterface>
	public I$SchemaName$GelInstructionObj lookupMacro( String macroBody );
	public I$SchemaName$GelInstructionObj rememberMacro( String macroBody, I$SchemaName$GelInstructionObj gel );
	public I$SchemaName$GelExecutableObj lookupExecutable( String execName );
	public I$SchemaName$GelExecutableObj rememberExecutable( String execName, I$SchemaName$GelExecutableObj gel );</CafeObjInterface>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public I$SchemaName$GelInstructionObj lookupMacro( String macroBody ) {
		I$SchemaName$GelInstructionObj gel = mapMacro.get( macroBody );
		return( gel );
	}

	public I$SchemaName$GelInstructionObj rememberMacro( String macroBody, I$SchemaName$GelInstructionObj gel ) {
		I$poptop Table DefSchemaName$GelInstructionObj found;
		found = mapMacro.get( macroBody );
		if( found == null ) {
			mapMacro.put( macroBody, gel );
			found = gel;
		}
		return( found );
	}

	public I$SchemaName$GelExecutableObj lookupExecutable( String execName ) {
		I$SchemaName$GelExecutableObj gel = mapExecutable.get( execName );
		return( gel );
	}

	public I$SchemaName$GelExecutableObj rememberExecutable( String execName, I$SchemaName$GelExecutableObj gel ) {
		I$poptop Table DefSchemaName$GelExecutableObj found;
		found = mapExecutable.get( execName );
		if( found == null ) {
			mapExecutable.put( execName, gel );
			found = gel;
		}
		return( found );
	}
</CafeObjImplementation>

		<CafeEditObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeEditObjImport>

		<CafeEditObjImplementation>
	public I$SchemaName$GelInstructionObj lookupMacro( String macroBody ) {
		throw new CFLibUsageException( getClass(), "lookupMacro", "You are not allowed to manipulate macros while objects are being edited" );
	}

	public I$SchemaName$GelInstructionObj rememberMacro( String macroBody, I$SchemaName$GelInstructionObj gel ) {
		throw new CFLibUsageException( getClass(), "rememberMacro", "You are not allowed to manipulate macros while objects are being edited" );
	}

	public I$SchemaName$GelExecutableObj lookupExecutable( String execName ) {
		throw new CFLibUsageException( getClass(), "lookupExecutable", "You are not allowed to manipulate macros while objects are being edited" );
	}

	public I$SchemaName$GelExecutableObj rememberExecutable( String execName, I$SchemaName$GelExecutableObj gel ) {
		throw new CFLibUsageException( getClass(), "rememberExecutable", "You are not allowed to manipulate macros while objects are being edited" );
	}
</CafeEditObjImplementation>

		<HPlusObjMembers>
		std::map&lt;std::string,I$SchemaName$GelInstructionObj*&gt; mapMacro;
		std::map&lt;std::string,I$SchemaName$GelExecutableObj*&gt; mapExecutable;</HPlusObjMembers>

		<CPlusObjInterface>
		$SchemaName$$TableName$Obj( I$SchemaName$TenantObj* tenant );
		virtual I$SchemaName$GelInstructionObj* lookupMacro( const std::string&amp; macroBody );
		virtual I$SchemaName$GelInstructionObj* rememberMacro( const std::string&amp; macroBody, I$SchemaName$GelInstructionObj* gel );
		virtual I$SchemaName$GelExecutableObj* lookupExecutable( const std::string&amp; macroBody );
		virtual I$SchemaName$GelExecutableObj* rememberExecutable( const std::string&amp; macroBody, I$SchemaName$GelExecutableObj* gel );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual I$SchemaName$GelInstructionObj* lookupMacro( const std::string&amp; macroBody ) = 0;
		virtual I$SchemaName$GelInstructionObj* rememberMacro( const std::string&amp; macroBody, I$SchemaName$GelInstructionObj* gel ) = 0;
		virtual I$SchemaName$GelExecutableObj* lookupExecutable( const std::string&amp; macroBody ) = 0;
		virtual I$SchemaName$GelExecutableObj* rememberExecutable( const std::string&amp; macroBody, I$SchemaName$GelExecutableObj* gel ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompilert;
	class MssCFGenFileObjt;
	class MssCFGenRuleObjt;
	class MssCFGenTruncObjt;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	$SchemaName$$TableName$Obj::$SchemaName$$TableName$Obj( I$SchemaName$TenantObj* tenant ) {
		if( tenant != NULL ) {
			schema = tenant-&gt;getSchema();
			pKey = NULL;
			buff = NULL;
			isNew = true;
			edit = NULL;
			getBuff()-&gt;setRequiredTenantId( tenant-&gt;getRequiredId() );
		}
		else {
			schema = NULL;
			pKey = NULL;
			buff = NULL;
			isNew = true;
			edit = NULL;
		}
	}

	I$SchemaName$GelInstructionObj* $SchemaName$$TableName$Obj::lookupMacro( const std::string&amp; macroBody ) {
		$poptop Table CPlusDefNamespace$::I$poptop Table DefSchemaName$GelInstructionObj* gel = NULL;
		auto searchMacro = mapMacro.find( macroBody );
		if( searchMacro != mapMacro.end() ) {
			gel = searchMacro-&gt;second;
		}
		return( gel );
	}

	I$SchemaName$GelInstructionObj* $SchemaName$$TableName$Obj::rememberMacro( const std::string&amp; macroBody, I$SchemaName$GelInstructionObj* gel ) {
		I$poptop Table DefSchemaName$GelInstructionObj* found;
		auto searchMacro = mapMacro.find( macroBody );
		if( searchMacro != mapMacro.end() ) {
			found = searchMacro-&gt;second;
		}
		else {
			mapMacro.insert( std::map&lt; std::string, I$SchemaName$GelInstructionObj* &gt;::value_type( macroBody, gel ) );
			found = gel;
		}
		return( found );
	}

	I$SchemaName$GelExecutableObj* $SchemaName$$TableName$Obj::lookupExecutable( const std::string&amp; execName ) {
		$poptop Table CPlusDefNamespace$::I$poptop Table DefSchemaName$GelExecutableObj* gel = NULL;
		auto searchExecutable = mapExecutable.find( execName );
		if( searchExecutable != mapExecutable.end() ) {
			gel = searchExecutable-&gt;second;
		}
		return( gel );
	}

	I$SchemaName$GelExecutableObj* $SchemaName$$TableName$Obj::rememberExecutable( const std::string&amp; execName, I$SchemaName$GelExecutableObj* gel ) {
		I$poptop Table DefSchemaName$GelExecutableObj* found;
		auto searchExecutable = mapExecutable.find( execName );
		if( searchExecutable != mapExecutable.end() ) {
			found = searchExecutable-&gt;second;
		}
		else {
			mapExecutable.insert( std::map&lt; std::string, I$SchemaName$GelExecutableObj* &gt;::value_type( execName, gel ) );
			found = gel;
		}
		return( found );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual I$SchemaName$GelInstructionObj* lookupMacro( const std::string&amp; macroBody );
		virtual I$SchemaName$GelInstructionObj* rememberMacro( const std::string&amp; macroBody, I$SchemaName$GelInstructionObj* gel );
		virtual I$SchemaName$GelExecutableObj* lookupExecutable( const std::string&amp; macroBody );
		virtual I$SchemaName$GelExecutableObj* rememberExecutable( const std::string&amp; macroBody, I$SchemaName$GelExecutableObj* gel );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual I$SchemaName$GelInstructionObj* lookupMacro( const std::string&amp; macroBody ) = 0;
		virtual I$SchemaName$GelInstructionObj* rememberMacro( const std::string&amp; macroBody, I$SchemaName$GelInstructionObj* gel ) = 0;
		virtual I$SchemaName$GelExecutableObj* lookupExecutable( const std::string&amp; macroBody ) = 0;
		virtual I$SchemaName$GelExecutableObj* rememberExecutable( const std::string&amp; macroBody, I$SchemaName$GelExecutableObj* gel ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	I$SchemaName$GelInstructionObj* $SchemaName$$TableName$EditObj::lookupMacro( const std::string&amp; macroBody ) {
		static const std::string S_ProcName( "lookupMacro" );
		static const std::string S_UsageMsg( "You are not allowed to manipulate macros while the cache is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}

	I$SchemaName$GelInstructionObj* $SchemaName$$TableName$EditObj::rememberMacro( const std::string&amp; macroBody, I$SchemaName$GelInstructionObj* gel ) {
		static const std::string S_ProcName( "rememberMacro" );
		static const std::string S_UsageMsg( "You are not allowed to manipulate macros while the cache is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}

	I$SchemaName$GelExecutableObj* $SchemaName$$TableName$EditObj::lookupExecutable( const std::string&amp; execName ) {
		static const std::string S_ProcName( "lookupExecutable" );
		static const std::string S_UsageMsg( "You are not allowed to manipulate macros while the cache is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}

	I$SchemaName$GelExecutableObj* $SchemaName$$TableName$EditObj::rememberExecutable( const std::string&amp; execName, I$SchemaName$GelExecutableObj* gel ) {
		static const std::string S_ProcName( "rememberExecutable" );
		static const std::string S_UsageMsg( "You are not allowed to manipulate macros while the cache is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelInstruction"
			TableClassCode="a916"
			DbName="gelinst"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="GEL Cache Id"
				IsNullable="false"
				DataType="GelCacheIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				GenerateId="true"
				DataType="GelInstructionIdGen" />
		<TableCol Name="ChainInstTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="ChainInstGelCacheId"
				Label="GEL Cache Id"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="ChainInstGelInstId"
				Label="GEL Instruction Id"
				IsNullable="true"
				GenerateId="true"
				DataType="GelInstructionIdGen" />
		<TextCol Name="SourceText"
				Label="Gel Source Text"
				IsNullable="false"
				MaxLen="2000000"
				InitValue="" />
		<PrimaryIndex Name="GelInstructionIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelinst_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GelInstructionTenantIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelinst_xtenant"
				Suffix="TenantIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
		</Index>
		<Index Name="GelInstructionGelCacheIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelinst_xgelcache"
				Suffix="GelCacheIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
		</Index>
		<Index Name="GelInstructionChainInstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelinst_xgelchain"
				Suffix="ChainIdx" >
			<IndexCol Name="ChainInstTenantId" IsAscending="true" />
			<IndexCol Name="ChainInstGelCacheId" IsAscending="true" />
			<IndexCol Name="ChainInstGelInstId" IsAscending="true" />
		</Index>

		<CafeObjInterface>
	public void linkChainInstruction( I$SchemaName$GelInstructionObj calledInstruction );
	public void addCalledInstruction( I$SchemaName$GelCacheObj gelCache, I$SchemaName$GelInstructionObj calledInstruction );
	public String expand( MssCFGenContext genContext );</CafeObjInterface>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public void linkChainInstruction( I$SchemaName$GelInstructionObj calledInstruction ) {
		final String S_ProcName = "linkChainInstruction";
		final String S_ChainInstAlreadySet = "ChainInst lookup already set for instruction ";
		if( null != getOptionalLookupChainInst() ) {
			throw new CFLibUsageException( getClass(), S_ProcName, S_ChainInstAlreadySet + getPKey().toString() );
		}
		I$SchemaName$GelInstructionEditObj editSelf = (I$SchemaName$GelInstructionEditObj)beginEdit();
		editSelf.setOptionalLookupChainInst( calledInstruction );
		editSelf.update();
		editSelf = null;
	}

	public void addCalledInstruction( I$SchemaName$GelCacheObj gelCache, I$SchemaName$GelInstructionObj calledInstruction ) {
		final String S_ProcName = "addCalledInstruction";
		final String S_ChainInstAlreadySet = "ChainInst lookup already set for instruction ";
		if( null != getOptionalLookupChainInst() ) {
			throw new CFLibUsageException( getClass(), S_ProcName, S_ChainInstAlreadySet + getPKey().toString() );
		}
		I$SchemaName$GelInstructionEditObj editSelf = (I$SchemaName$GelInstructionEditObj)beginEdit();
		editSelf.setOptionalLookupChainInst( calledInstruction );
		editSelf.update();
		editSelf = null;
	}

	public String expand( MssCFGenContext genContext ) {
		throw new RuntimeException( &quot;$SchemaName$GelInstructionObj.expand() Must be overloaded by specializing instruction implementation&quot; );
	}
</CafeObjImplementation>

		<CafeEditObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeEditObjImport>

		<CafeEditObjImplementation>
	public void linkChainInstruction( I$SchemaName$GelInstructionObj calledInstruction ) {
		throw new RuntimeException( &quot;$SchemaName$GelInstructionEditObj.linkChainInstruction() You are not allowed to link an instruction during edits&quot; );
	}

	public void addCalledInstruction( I$SchemaName$GelCacheObj gelCache, I$SchemaName$GelInstructionObj calledInstruction ) {
		throw new RuntimeException( &quot;$SchemaName$GelInstructionEditObj.linkChainInstruction() You are not allowed to add an instruction during edits&quot; );
	}

	public String expand( MssCFGenContext genContext ) {
		throw new RuntimeException( &quot;$SchemaName$GelInstructionEditObj.expand() You are not allowed to expand an object while it is being edited&quot; );
	}
</CafeEditObjImplementation>

		<CPlusObjInterface>
		virtual void linkChainInstruction( I$SchemaName$GelInstructionObj* calledInstruction );
		virtual void addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction );
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual void linkChainInstruction( I$SchemaName$GelInstructionObj* calledInstruction ) = 0;
		virtual void addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction ) = 0;
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompilert;
	class MssCFGenFileObjt;
	class MssCFGenRuleObjt;
	class MssCFGenTruncObjt;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	void $SchemaName$GelInstructionObj::linkChainInstruction( I$SchemaName$GelInstructionObj* calledInstruction ) {
		static const std::string S_ProcName( "linkChainInstruction" );
		static const std::string S_ChainInstAlreadySet( "ChainInst lookup already set for instruction " );
		if( NULL != getOptionalLookupChainInst() ) {
			std::string msg( S_ChainInstAlreadySet );
			msg.append( getPKey()-&gt;toString() );
			throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, msg );
		}
		I$SchemaName$GelInstructionEditObj* editSelf = dynamic_cast&lt;I$SchemaName$GelInstructionEditObj*&gt;( beginEdit() );
		editSelf-&gt;setOptionalLookupChainInst( calledInstruction );
		editSelf-&gt;update();
		editSelf = NULL;
	}

	void $SchemaName$GelInstructionObj::addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction ) {
		static const std::string S_ProcName( "addCalledInstruction" );
		static const std::string S_ChainInstAlreadySet( "ChainInst lookup already set for instruction " );
		if( NULL != getOptionalLookupChainInst() ) {
			std::string msg( S_ChainInstAlreadySet );
			msg.append( getPKey()-&gt;toString() );
			throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, msg );
		}
		I$SchemaName$GelInstructionEditObj* editSelf = dynamic_cast&lt;I$SchemaName$GelInstructionEditObj*&gt;( beginEdit() );
		editSelf-&gt;setOptionalLookupChainInst( calledInstruction );
		editSelf-&gt;update();
		editSelf = NULL;
	}

	std::string $SchemaName$GelInstructionObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );
		static const std::string S_Msg( "Implementation must be overridden by Instruction specialization" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		throw cflib::CFLibMustOverrideException( CLASS_NAME, S_ProcName, S_Msg );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual void linkChainInstruction( I$SchemaName$GelInstructionObj* calledInstruction );
		virtual void addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction );
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual void linkChainInstruction( I$SchemaName$GelInstructionObj* calledInstruction ) = 0;
		virtual void addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction ) = 0;
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	void $SchemaName$GelInstructionEditObj::linkChainInstruction( I$SchemaName$GelInstructionObj* calledInstruction ) {
		static const std::string S_ProcName( "linkChainInstruction" );
		static const std::string S_UsageMsg( "You are not allowed to link chain instructions while this object is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}

	void $SchemaName$GelInstructionEditObj::addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction ) {
		static const std::string S_ProcName( "addCalledInstruction" );
		static const std::string S_UsageMsg( "You are not allowed to add called instructions while this object is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}

	std::string $SchemaName$GelInstructionEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelIterator"
			TableClassCode="a917"
			DbName="geliter"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				DataType="GelCacheIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="IteratorName"
				IsNullable="false"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandBefore"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandFirst"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandEach"
				IsNullable="false"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandLast"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandLone"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandEmpty"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandAfter"
				IsNullable="true"
				DataType="GenItemNameType" />
		<PrimaryIndex Name="GelIteratorIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="geliter_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="ExpandBeforeIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="geliter_xbefore"
				Suffix="BeforeIdx" >
			<IndexCol Name="ExpandBefore" IsAscending="true" />
		</Index>
		<Index Name="ExpandFirstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="geliter_xfirst"
				Suffix="FirstIdx" >
			<IndexCol Name="ExpandFirst" IsAscending="true" />
		</Index>
		<Index Name="ExpandEachIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="geliter_xeach"
				Suffix="EachIdx" >
			<IndexCol Name="ExpandEach" IsAscending="true" />
		</Index>
		<Index Name="ExpandLastIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="geliter_xlast"
				Suffix="LastIdx" >
			<IndexCol Name="ExpandLast" IsAscending="true" />
		</Index>
		<Index Name="ExpandLoneIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="geliter_xlone"
				Suffix="LoneIdx" >
			<IndexCol Name="ExpandLone" IsAscending="true" />
		</Index>
		<Index Name="ExpandEmptyIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="geliter_xempty"
				Suffix="EmptyIdx" >
			<IndexCol Name="ExpandEmpty" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="geliter_super"
				Suffix="SuperClass"
				FromIndex="GelIteratorIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.*;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		String						itemExpansion = null;
		ICFLibAnyObj				detailDef = null;
		MssCFGenContext				detailContext = null;
		int							idx;
		int							numItems = 0;
		List&lt;ICFLibAnyObj&gt;		detailList;

		I$SchemaName$GenItemObj		itemBefore = null;
		I$SchemaName$GenItemObj		itemAfter = null;
		I$SchemaName$GenItemObj		itemEmpty = null;

		I$SchemaName$GenItemObj		itemRule = null;

		String					failedBefore = null;
		String					failedFirst = null;
		String					failedEach = null;
		String					failedLast = null;
		String					failedAfter = null;
		String					failedLone = null;
		String					failedEmpty = null;

		String					expansion = null;
		MssCFGenContext			subContext = null;

		final String S_ProcName = &quot;$SchemaName$GelIteratorObj.expand() &quot;;

		String				iteratorName = getRequiredIteratorName();
		String				bodyBefore = getOptionalExpandBefore();
		String				bodyFirst = getOptionalExpandFirst();
		String				bodyEach = getRequiredExpandEach();
		String				bodyLast = getOptionalExpandLast();
		String				bodyAfter = getOptionalExpandAfter();
		String				bodyLone = getOptionalExpandLone();
		String				bodyEmpty = getOptionalExpandEmpty();

		String generatingBuild = genContext.getGeneratingBuild();
		MssCFEngine genEngine = genContext.getGenEngine();

		I$SchemaName$GenItemObj genItem = genEngine.findContextItem(genContext, iteratorName );
		if( genItem == null ) {
			genEngine.getLog().message( &quot;Could not find iterator \&quot;&quot;
				+ iteratorName
				+ &quot;\&quot; attempting to expand \&quot;&quot;
				+ &quot;$$&quot; + getRequiredSourceText() + &quot;$$\&quot;&quot; );
			return( null );
		}

		if( ! ( genItem instanceof MssCFGenIteratorObj ) ) {
			genEngine.getLog().message( &quot;Context item \&quot;&quot;
				+ iteratorName
				+ &quot;\&quot; must be a MssCFGenIteratorObj, not a &quot;
				+ genItem.getClass().getPackage().getName() + &quot;.&quot; + genItem.getClass().getSimpleName()
				+ &quot;.  \&quot;&quot;
				+ &quot;$$&quot; + getRequiredSourceText() + &quot;$$&quot;
				+ &quot;\&quot; is invalid&quot; );
			return( null );
		}

		MssCFGenIteratorObj	iterator = (MssCFGenIteratorObj)genItem;

		String detailClassName;
		if (iterator.getDetailClass() != null) {
			detailClassName = iterator.getDetailClass().getRequiredName();
		}
		else {
			detailClassName = genEngine.getAnyClassName();
		}

		iteratorName = iterator.getRequiredName();

		if( ( iteratorName == null ) || ( 0 == iteratorName.length() ) ) {
			throw new RuntimeException( S_ProcName +  &quot;Iterator is not properly named&quot; );
		}

		if( ( detailClassName == null ) || ( 0 == detailClassName.length() ) ) {
			throw new RuntimeException( S_ProcName +  &quot;Iterator must specify a detail class name&quot; );
		}

	//	Create a sub-context for locating the iterators

		subContext = genEngine.getGenContextFactory().newGenContext( generatingBuild,
			genContext,
			detailClassName,
			null );
		subContext.setPrevContext( genContext );

		if( bodyBefore != null ) {
			failedBefore = &quot;$$&quot; + bodyBefore + &quot;$$&quot;;
			itemBefore = genEngine.findContextItem( genContext, bodyBefore );
			if( itemBefore == null ) {
				genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
					+ iteratorName
					+ &quot;\&quot; &quot;
					+ MssCFGelCompiler._ITERATOR_BEFORE
					+ &quot; \&quot;&quot;
					+ bodyBefore
					+ &quot;\&quot;&quot; );
			}
		}

		if( bodyAfter != null ) {
			failedAfter = &quot;$$&quot; + bodyAfter + &quot;$$&quot;;
			itemAfter = genEngine.findContextItem( genContext, bodyAfter );
			if( itemAfter == null ) {
				genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
					+ iteratorName
					+ &quot;\&quot; &quot;
					+ MssCFGelCompiler._ITERATOR_AFTER
					+ &quot; \&quot;&quot;
					+ bodyAfter
					+ &quot;\&quot;&quot; );
			}
		}

		if( bodyEmpty != null ) {
			failedEmpty = &quot;$$&quot; + bodyEmpty + &quot;$$&quot;;
			if( ! bodyEmpty.equals( MssCFGelCompiler._ITERATOR_EMPTY ) ) {
				itemEmpty = genEngine.findContextItem( genContext, bodyEmpty );
				if( itemEmpty == null ) {
					genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
						+ iteratorName
						+ &quot;\&quot; &quot;
						+ MssCFGelCompiler._ITERATOR_EMPTY
						+ &quot; \&quot;&quot;
						+ bodyEmpty
						+ &quot;\&quot;&quot; );
				}
			}
		}

		if( bodyFirst != null ) {
			failedFirst = &quot;$$&quot; + bodyFirst + &quot;$$&quot;;
		}

		if( bodyEach != null ) {
			failedEach = &quot;$$&quot; + bodyEach + &quot;$$&quot;;
		}

		if( bodyLast != null ) {
			failedLast = &quot;$$&quot; + bodyLast + &quot;$$&quot;;
		}

		if( bodyLone != null ) {
			failedLone = &quot;$$&quot; + bodyLone + &quot;$$&quot;;
		}

	//	compile the iteration.  If we got a null iteration back, something
	//	went wrong and we treat the expansion as being in error.

		detailList = iterator.getDetailList( genContext );
		if( detailList == null ) {
			genEngine.getLog().message( &quot;Could not get &quot;
				+ iteratorName
				+ &quot; detail object iteration.  \&quot;&quot;
				+ &quot;$$&quot; + getRequiredSourceText() + &quot;$$&quot;
				+ &quot;\&quot; is invalid&quot; );
			return( null );
		}

	//	Prepare to perform the expansions

		expansion = &quot;&quot;;

	//	If a BEFORE item is provided, we always expand it using the CURRENT
	//	context, not a sub-context.

		if( bodyBefore != null ) {
			if( itemBefore != null ) {
				itemExpansion = genContext.expandItemBody( itemBefore );
				if( itemExpansion != null ) {
					expansion = expansion + itemExpansion;
				}
				else {
					expansion = expansion + failedBefore;
				}
			}
			else {
				expansion = expansion + failedBefore;
			}
		}

	//	How we perform the expansion depends on what iterator limbs
	//	have been specified and on the number of items to process.

		numItems = detailList.size();

		//	If the detail set is empty, expand EMPTY if it&apos;s provided

		if( numItems == 0 ) {
			if( bodyEmpty != null ) {
				if( itemEmpty != null ) {
					itemExpansion = genContext.expandItemBody( itemEmpty );
					if( itemExpansion != null ) {
						expansion = expansion + itemExpansion;
					}
					else {
						expansion = expansion + failedEmpty;
					}
				}
				else if( ! bodyEmpty.equals( MssCFGelCompiler._ITERATOR_EMPTY ) ) {
					expansion = expansion + failedEmpty;
				}
			}
			else {
				genEngine.getLog().message( &quot;Expansion of iterator \&quot;&quot; + iteratorName + &quot;\&quot; returned an empty set&quot; );
			}
		}

	//	If the detail set has one item, preferentially expand one of
	//	LONE, LAST, FIRST, or EACH limb

		else if( numItems == 1 ) {

			detailDef = detailList.get(0);
			detailContext = genEngine.getGenContextFactory().newGenContext( generatingBuild,
				genContext,
				detailDef.getGenDefName(),
				detailDef );
			detailContext.setPrevContext( genContext );

			if( bodyLone != null ) {
				itemRule = genEngine.findContextItem( detailContext, bodyLone );
				if( itemRule != null ) {
					itemExpansion = detailContext.expandItemBody( itemRule );
					if( itemExpansion != null ) {
						expansion = expansion + itemExpansion;
					}
					else {
						expansion = expansion + failedLone;
					}
				}
				else {
					genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
						+ iteratorName
						+ &quot;\&quot; &quot;
						+ MssCFGelCompiler._ITERATOR_LONE
						+ &quot; \&quot;&quot;
						+ bodyLone
						+ &quot;\&quot;&quot; );
					expansion = expansion + failedLone;
				}
			}
			else if( bodyFirst != null ) {
				itemRule = genEngine.findContextItem( detailContext, bodyFirst );
				if( itemRule != null ) {
					itemExpansion = detailContext.expandItemBody( itemRule );
					if( itemExpansion != null ) {
						expansion = expansion + itemExpansion;
					}
					else {
						expansion = expansion + failedFirst;
					}
				}
				else {
					genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
						+ iteratorName
						+ &quot;\&quot; &quot;
						+ MssCFGelCompiler._ITERATOR_FIRST
						+ &quot; \&quot;&quot;
						+ bodyFirst
						+ &quot;\&quot;&quot; );
					expansion = expansion + failedFirst;
				}
			}
			else if( bodyLast != null ) {
				itemRule = genEngine.findContextItem( detailContext, bodyLast );
				if( itemRule != null ) {
					itemExpansion = detailContext.expandItemBody( itemRule );
					if( itemExpansion != null ) {
						expansion = expansion + itemExpansion;
					}
					else {
						expansion = expansion + failedLast;
					}
				}
				else {
					genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
						+ iteratorName
						+ &quot;\&quot; &quot;
						+ MssCFGelCompiler._ITERATOR_LAST
						+ &quot; \&quot;&quot;
						+ bodyLast
						+ &quot;\&quot;&quot; );
					expansion = expansion + failedLast;
				}
			}
			else {
				itemRule = genEngine.findContextItem( detailContext, bodyEach );
				if( itemRule != null ) {
					itemExpansion = detailContext.expandItemBody( itemRule );
					if( itemExpansion != null ) {
						expansion = expansion + itemExpansion;
					}
					else {
						expansion = expansion + failedEach;
					}
				}
				else {
					genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
						+ iteratorName
						+ &quot;\&quot; &quot;
						+ MssCFGelCompiler._ITERATOR_EACH
						+ &quot; \&quot;&quot;
						+ bodyEach
						+ &quot;\&quot;&quot; );
					expansion = expansion + failedEach;
				}
			}
		}
		else {

	//	If the detail set has n items:

	//		The first item is expanded by FIRST or EACH

			detailDef = detailList.get(0);
			detailContext = genEngine.getGenContextFactory().newGenContext( generatingBuild,
				genContext,
				detailDef.getGenDefName(),
				detailDef );
			detailContext.setPrevContext( genContext );

			if( bodyFirst != null ) {
				itemRule = genEngine.findContextItem( detailContext, bodyFirst );
				if( itemRule != null ) {
					itemExpansion = detailContext.expandItemBody( itemRule );
					if( itemExpansion != null ) {
						expansion = expansion + itemExpansion;
					}
					else {
						expansion = expansion + failedFirst;
					}
				}
				else {
					genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
						+ iteratorName
						+ &quot;\&quot; &quot;
						+ MssCFGelCompiler._ITERATOR_FIRST
						+ &quot; \&quot;&quot;
						+ bodyFirst
						+ &quot;\&quot;&quot; );
					expansion = expansion + failedFirst;
				}
			}
			else {
				itemRule = genEngine.findContextItem( detailContext, bodyEach );
				if( itemRule != null ) {
					itemExpansion = detailContext.expandItemBody( itemRule );
					if( itemExpansion != null ) {
						expansion = expansion + itemExpansion;
					}
					else {
						expansion = expansion + failedEach;
					}
				}
				else {
					genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
						+ iteratorName
						+ &quot;\&quot; &quot;
						+ MssCFGelCompiler._ITERATOR_EACH
						+ &quot; \&quot;&quot;
						+ bodyEach
						+ &quot;\&quot;&quot; );
					expansion = expansion + failedEach;
				}
			}

	//		The middle items are always expanded by EACH

			for( idx = 1; idx &lt; numItems - 1; idx ++ ) {

				detailDef = detailList.get( idx );
				detailContext = genEngine.getGenContextFactory().newGenContext( generatingBuild,
					genContext,
					detailDef.getGenDefName(),
					detailDef );
				detailContext.setPrevContext( genContext );

				itemRule = genEngine.findContextItem( detailContext, bodyEach );
				if( itemRule != null ) {
					itemExpansion = detailContext.expandItemBody( itemRule );
					if( itemExpansion != null ) {
						expansion = expansion + itemExpansion;
					}
					else {
						expansion = expansion + failedEach;
					}
				}
				else {
					genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
						+ iteratorName
						+ &quot;\&quot; &quot;
						+ MssCFGelCompiler._ITERATOR_EACH
						+ &quot; \&quot;&quot;
						+ bodyEach
						+ &quot;\&quot;&quot; );
					expansion = expansion + failedEach;
				}
			}

	//		The last item is expanded by LAST or EACH

			detailDef = detailList.get( numItems - 1 );
			detailContext = genEngine.getGenContextFactory().newGenContext( generatingBuild,
				genContext,
				detailDef.getGenDefName(),
				detailDef );
			detailContext.setPrevContext( genContext );

			if( bodyLast != null ) {
				itemRule = genEngine.findContextItem( detailContext, bodyLast );
				if( itemRule != null ) {
					itemExpansion = detailContext.expandItemBody( itemRule );
					if( itemExpansion != null ) {
						expansion = expansion + itemExpansion;
					}
					else {
						expansion = expansion + failedLast;
					}
				}
				else {
					genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
						+ iteratorName
						+ &quot;\&quot; &quot;
						+ MssCFGelCompiler._ITERATOR_LAST
						+ &quot; \&quot;&quot;
						+ bodyLast
						+ &quot;\&quot;&quot; );
					expansion = expansion + failedLast;
				}
			}
			else {
				itemRule = genEngine.findContextItem( detailContext, bodyEach );
				if( itemRule != null ) {
					itemExpansion = detailContext.expandItemBody( itemRule );
					if( itemExpansion != null ) {
						expansion = expansion + itemExpansion;
					}
					else {
						expansion = expansion + failedEach;
					}
				}
				else {
					genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
						+ iteratorName
						+ &quot;\&quot; &quot;
						+ MssCFGelCompiler._ITERATOR_EACH
						+ &quot; \&quot;&quot;
						+ bodyEach
						+ &quot;\&quot;&quot; );
					expansion = expansion + failedEach;
				}
			}
		}

	//	If an AFTER item is provided, we always expand it using the CURRENT
	//	context, not a sub-context.

		if( bodyAfter != null ) {
			if( itemAfter != null ) {
				itemExpansion = genContext.expandItemBody( itemAfter );
				if( itemExpansion != null ) {
					expansion = expansion + itemExpansion;
				}
				else {
					expansion = expansion + failedAfter;
				}
			}
			else {
				expansion = expansion + failedAfter;
			}
		}

	//	Return the cumulative results of the expansion

		return( expansion );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {
	std::string $SchemaName$GelIteratorObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( &quot;GelIterator.expand&quot; );
		static const std::string S_GenContext( "genContext" );
		static const std::string S_IteratorName( "IteratorName" );
		static const std::string S_DetailClassName( "DetailClassName" );
		static const std::string S_BodyEach( "BodyEach" );
		static const std::string S_Dollar( "$$" );
		static const std::string S_DQuote( "\"" );
		static const std::string S_CouldNotFindExpansionItem( "Could not find expansion item for iterator \"" );
		static const std::string S_QuoteSpace( "\" " );
		static const std::string S_SpaceQuote( " \"" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		std::string iteratorName = getRequiredIteratorName();
		if( iteratorName.length() &lt;= 0 ) {
			throw cflib::CFLibEmptyArgumentException( CLASS_NAME, S_ProcName, 0, S_IteratorName );
		}

		std::string bodyEach = getRequiredExpandEach();
		if( bodyEach.length() &lt;= 0 ) {
			throw cflib::CFLibEmptyArgumentException( CLASS_NAME, S_ProcName, 0, S_BodyEach );
		}

		std::string emptyString;
		std::string itemExpansion;
		cflib::ICFLibAnyObj* detailDef = NULL;
		MssCFGenContext* detailContext = NULL;
		int idx;
		int numItems = 0;

		I$SchemaName$GenItemObj* itemBefore = NULL;
		I$SchemaName$GenItemObj* itemAfter = NULL;
		I$SchemaName$GenItemObj* itemEmpty = NULL;

		I$SchemaName$GenItemObj* itemRule = NULL;

		std::string* failedBefore = NULL;
		std::string* failedFirst = NULL;
		std::string* failedEach = NULL;
		std::string* failedLast = NULL;
		std::string* failedAfter = NULL;
		std::string* failedLone = NULL;
		std::string* failedEmpty = NULL;

		const std::string* bodyBefore = getOptionalExpandBeforeReference();
		const std::string* bodyFirst = getOptionalExpandFirstReference();
		const std::string* bodyLast = getOptionalExpandLastReference();
		const std::string* bodyAfter = getOptionalExpandAfterReference();
		const std::string* bodyLone = getOptionalExpandLoneReference();
		const std::string* bodyEmpty = getOptionalExpandEmptyReference();

		std::string generatingBuild = genContext-&gt;getGeneratingBuild();

		MssCFEngine* genEngine = genContext-&gt;getGenEngine();

	//	The genItem should be an MssCFGenIterator

		I$SchemaName$GenItemObj* genItem = genEngine-&gt;findContextItem( genContext, iteratorName );
		if( genItem == NULL ) {
			static const std::string S_CouldNotFindIterator( "Could not find iterator \"" );
			static const std::string S_Attempting( "\" attempting to expand \"" );
			std::string S_Msg( S_CouldNotFindIterator + iteratorName + S_Attempting + getRequiredSourceText() + S_DQuote );
			genEngine-&gt;getLog()-&gt;message( S_Msg );
			genContext-&gt;setExpansionIsNull();
			if( failedBefore != NULL ) {
				delete failedBefore;
				failedBefore = NULL;
			}
			if( failedFirst != NULL ) {
				delete failedFirst;
				failedFirst = NULL;
			}
			if( failedEach != NULL ) {
				delete failedEach;
				failedEach = NULL;
			}
			if( failedLast != NULL ) {
				delete failedLast;
				failedLast = NULL;
			}
			if( failedAfter != NULL ) {
				delete failedAfter;
				failedAfter = NULL;
			}
			if( failedLone != NULL ) {
				delete failedLone;
				failedLone = NULL;
			}
			if( failedEmpty != NULL ) {
				delete failedEmpty;
				failedEmpty = NULL;
			}
			return( emptyString );
		}

		MssCFGenIteratorObj* iterator = dynamic_cast&lt;MssCFGenIteratorObj*&gt;( genItem );
		if( iterator == NULL ) {
			static const std::string S_ContextItem( "Context item \"" );
			static const std::string S_MustBe( "\" must be an MssCFGenIteratorObj, not a \"" );
			static const std::string S_PeriodSpace( ". \"" );
			std::string S_Msg( S_ContextItem + iteratorName + S_MustBe + genItem-&gt;getClassName() + S_PeriodSpace + getRequiredSourceText() + S_DQuote );
			genEngine-&gt;getLog()-&gt;message( S_Msg );
			genContext-&gt;setExpansionIsNull();
			if( failedBefore != NULL ) {
				delete failedBefore;
				failedBefore = NULL;
			}
			if( failedFirst != NULL ) {
				delete failedFirst;
				failedFirst = NULL;
			}
			if( failedEach != NULL ) {
				delete failedEach;
				failedEach = NULL;
			}
			if( failedLast != NULL ) {
				delete failedLast;
				failedLast = NULL;
			}
			if( failedAfter != NULL ) {
				delete failedAfter;
				failedAfter = NULL;
			}
			if( failedLone != NULL ) {
				delete failedLone;
				failedLone = NULL;
			}
			if( failedEmpty != NULL ) {
				delete failedEmpty;
				failedEmpty = NULL;
			}
			return( emptyString );
		}

	//	Get the detailClassName

		std::string detailClassName;
		if( iterator-&gt;getDetailClass() != NULL ) {
			detailClassName = iterator-&gt;getDetailClass()-&gt;getRequiredName();
		}
		else {
			detailClassName = genEngine-&gt;getAnyClassName();
		}

		if( detailClassName.length() &lt;= 0 ) {
			throw cflib::CFLibEmptyArgumentException( CLASS_NAME, S_ProcName, 0, S_DetailClassName );
		}

	//	Resolve the optional expansions

		if( bodyBefore != NULL ) {
			failedBefore = new std::string( S_Dollar + *bodyBefore + S_Dollar );
			itemBefore = genEngine-&gt;findContextItem( genContext, *bodyBefore );
			if( itemBefore == NULL ) {
				std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_BEFORE + S_SpaceQuote + *bodyBefore + S_DQuote );
				genEngine-&gt;getLog()-&gt;message( S_Msg );
			}
		}

		if( bodyAfter != NULL ) {
			failedAfter = new std::string( S_Dollar + *bodyAfter + S_Dollar );
			itemAfter = genEngine-&gt;findContextItem( genContext, *bodyAfter );
			if( itemAfter == NULL ) {
				std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_AFTER + S_SpaceQuote + *bodyAfter + S_DQuote );
				genEngine-&gt;getLog()-&gt;message( S_Msg );
			}
		}

		if( bodyEmpty != NULL ) {
			failedEmpty = new std::string( S_Dollar + *bodyEmpty + S_Dollar );
			if( *bodyEmpty != MssCFGelCompiler::_ITERATOR_EMPTY ) {
				itemEmpty = genEngine-&gt;findContextItem( genContext, *bodyEmpty );
				if( itemEmpty == NULL ) {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_EMPTY + S_SpaceQuote + *bodyEmpty + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
				}
			}
		}

		if( bodyFirst != NULL ) {
			failedFirst = new std::string( S_Dollar + *bodyFirst + S_Dollar );
		}

		failedEach = new std::string( S_Dollar + bodyEach + S_Dollar );

		if( bodyLast != NULL ) {
			failedLast = new std::string( S_Dollar + *bodyLast + S_Dollar );
		}

		if( bodyLone != NULL ) {
			failedLone = new std::string( S_Dollar + *bodyLone + S_Dollar );
		}

	//	Prepare to perform the expansions

		std::string expansion;

	//	Get the detailList

		std::vector&lt;cflib::ICFLibAnyObj*&gt;* detailList = iterator-&gt;getDetailList( genContext );
		if( detailList == NULL ) {
			static const std::string S_CouldNotGet( "Could not get " );
			static const std::string S_DetailIteration( " detail object iteration.  \"$$" );
			static const std::string S_IsInvalid( "$$\" is invalid" );
			std::string S_Msg( S_CouldNotGet + iteratorName + S_DetailIteration + getRequiredSourceText() + S_IsInvalid );
			genEngine-&gt;getLog()-&gt;message( S_Msg );
			genContext-&gt;setExpansionIsNull();
			if( failedBefore != NULL ) {
				delete failedBefore;
				failedBefore = NULL;
			}
			if( failedFirst != NULL ) {
				delete failedFirst;
				failedFirst = NULL;
			}
			if( failedEach != NULL ) {
				delete failedEach;
				failedEach = NULL;
			}
			if( failedLast != NULL ) {
				delete failedLast;
				failedLast = NULL;
			}
			if( failedAfter != NULL ) {
				delete failedAfter;
				failedAfter = NULL;
			}
			if( failedLone != NULL ) {
				delete failedLone;
				failedLone = NULL;
			}
			if( failedEmpty != NULL ) {
				delete failedEmpty;
				failedEmpty = NULL;
			}
			return( emptyString );
		}

	//	If a BEFORE item is provided, we always expand it using the CURRENT
	//	context, not a sub-context.

		if( bodyBefore != NULL ) {
			if( itemBefore != NULL ) {
				itemExpansion = genContext-&gt;expandItemBody( itemBefore );
				if( ! genContext-&gt;isExpansionNull() ) {
					expansion.append( itemExpansion );
				}
				else {
					expansion.append( *failedBefore );
				}
			}
			else {
				expansion.append( *failedBefore );
			}
			genContext-&gt;clearExpansionIsNull();
		}

	//	How we perform the expansion depends on what iterator limbs
	//	have been specified and on the number of items to process.

		numItems = detailList-&gt;size();

		//	If the detail set is empty, expand EMPTY if it&apos;s provided

		if( numItems == 0 ) {
			if( bodyEmpty != NULL ) {
				if( itemEmpty != NULL ) {
					itemExpansion = genContext-&gt;expandItemBody( itemEmpty );
					expansion.append( itemExpansion );
				}
				else if( *bodyEmpty != MssCFGelCompiler::_ITERATOR_EMPTY ) {
					expansion.append( *failedEmpty );
				}
			}
			else {
				static const std::string S_ExpansionOfIterator( "Expansion of iterator \"" );
				static const std::string S_ReturnedAnEmptySet( "\" returned an empty set" );
				std::string S_Msg( S_ExpansionOfIterator + iteratorName + S_ReturnedAnEmptySet );
				genEngine-&gt;getLog()-&gt;message( S_Msg );
			}
		}

	//	If the detail set has one item, preferentially expand one of
	//	LONE, LAST, FIRST, or EACH limb

		else if( numItems == 1 ) {

			detailDef = detailList-&gt;front();
			detailContext = genEngine-&gt;getGenContextFactory()-&gt;newGenContext( generatingBuild,
				genContext,
				detailDef-&gt;getGenDefName(),
				detailDef );
			detailContext-&gt;setPrevContext( genContext );

			if( bodyLone != NULL ) {
				itemRule = genEngine-&gt;findContextItem( detailContext, *bodyLone );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedLone );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_LONE + S_SpaceQuote + *bodyLone + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedLone );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			else if( bodyFirst != NULL ) {
				itemRule = genEngine-&gt;findContextItem( detailContext, *bodyFirst );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedFirst );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_FIRST + S_SpaceQuote + *bodyFirst + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedFirst );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			else if( bodyLast != NULL ) {
				itemRule = genEngine-&gt;findContextItem( detailContext, *bodyLast );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedLast );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_LAST + S_SpaceQuote + *bodyLast + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedLast );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			else {
				itemRule = genEngine-&gt;findContextItem( detailContext, bodyEach );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedEach );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_EACH + S_SpaceQuote + bodyEach + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedEach );
				}
				detailContext-&gt;clearExpansionIsNull();
			}

			while( ( detailContext != NULL ) &amp;&amp; ( detailContext != genContext ) ) {
				detailContext = detailContext-&gt;release();
			}
			detailContext = NULL;
		}
		else {

	//	If the detail set has n items:

	//		The first item is expanded by FIRST or EACH

			detailDef = detailList-&gt;front();
			detailContext = genEngine-&gt;getGenContextFactory()-&gt;newGenContext( generatingBuild,
				genContext,
				detailDef-&gt;getGenDefName(),
				detailDef );
			detailContext-&gt;setPrevContext( genContext );

			if( bodyFirst != NULL ) {
				itemRule = genEngine-&gt;findContextItem( detailContext, *bodyFirst );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedFirst );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_FIRST + S_SpaceQuote + *bodyFirst + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedFirst );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			else {
				itemRule = genEngine-&gt;findContextItem( detailContext, bodyEach );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedEach );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_EACH + S_SpaceQuote + bodyEach + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedEach );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			while( ( detailContext != NULL ) &amp;&amp; ( detailContext != genContext ) ) {
				detailContext = detailContext-&gt;release();
			}
			detailContext = NULL;

	//		The middle items are always expanded by EACH

			auto iterItems = detailList-&gt;begin();
			iterItems ++;
			for( idx = 1; idx &lt; numItems - 1; idx ++ ) {

				detailDef = *iterItems;
				iterItems ++;

				detailContext = genEngine-&gt;getGenContextFactory()-&gt;newGenContext( generatingBuild,
					genContext,
					detailDef-&gt;getGenDefName(),
					detailDef );
				detailContext-&gt;setPrevContext( genContext );

				itemRule = genEngine-&gt;findContextItem( detailContext, bodyEach );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedEach );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_EACH + S_SpaceQuote + bodyEach + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedEach );
				}
				detailContext-&gt;clearExpansionIsNull();
				while( ( detailContext != NULL ) &amp;&amp; ( detailContext != genContext ) ) {
					detailContext = detailContext-&gt;release();
				}
				detailContext = NULL;
			}

	//		The last item is expanded by LAST or EACH

			detailDef = detailList-&gt;back();
			detailContext = genEngine-&gt;getGenContextFactory()-&gt;newGenContext( generatingBuild,
				genContext,
				detailDef-&gt;getGenDefName(),
				detailDef );
			detailContext-&gt;setPrevContext( genContext );

			if( bodyLast != NULL ) {
				itemRule = genEngine-&gt;findContextItem( detailContext, *bodyLast );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedLast );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_LAST + S_SpaceQuote + *bodyBefore + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedLast );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			else {
				itemRule = genEngine-&gt;findContextItem( detailContext, bodyEach );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedEach );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_EACH + S_SpaceQuote + bodyEach + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedEach );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			while( ( detailContext != NULL ) &amp;&amp; ( detailContext != genContext ) ) {
				detailContext = detailContext-&gt;release();
			}
			detailContext = NULL;
		}

	//	If an AFTER item is provided, we always expand it using the CURRENT
	//	context, not a sub-context.

		if( bodyAfter != NULL ) {
			if( itemAfter != NULL ) {
				itemExpansion = genContext-&gt;expandItemBody( itemAfter );
				if( ! genContext-&gt;isExpansionNull() ) {
					expansion.append( itemExpansion );
				}
				else {
					expansion.append( *failedAfter );
				}
			}
			else {
				expansion.append( *failedAfter );
			}
			genContext-&gt;clearExpansionIsNull();
		}

	//	Release the detail context

		while( ( detailContext != NULL ) &amp;&amp; ( detailContext != genContext ) ) {
			detailContext = detailContext-&gt;release();
		}

	//	Delete the detail list

		if( detailList != NULL ) {
			delete detailList;
			detailList = NULL;
		}

	//	Release local allocations

		if( failedBefore != NULL ) {
			delete failedBefore;
			failedBefore = NULL;
		}
		if( failedFirst != NULL ) {
			delete failedFirst;
			failedFirst = NULL;
		}
		if( failedEach != NULL ) {
			delete failedEach;
			failedEach = NULL;
		}
		if( failedLast != NULL ) {
			delete failedLast;
			failedLast = NULL;
		}
		if( failedAfter != NULL ) {
			delete failedAfter;
			failedAfter = NULL;
		}
		if( failedLone != NULL ) {
			delete failedLone;
			failedLone = NULL;
		}
		if( failedEmpty != NULL ) {
			delete failedEmpty;
			failedEmpty = NULL;
		}

	//	Return the cumulative results of the expansion

		genContext-&gt;clearExpansionIsNull();
		return( expansion );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelIteratorEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelSpread"
			TableClassCode="a918"
			DbName="gelspred"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				DataType="GelCacheIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="IteratorName"
				IsNullable="false"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandBetween"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandBefore"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandFirst"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandEach"
				IsNullable="false"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandLast"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandLone"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandEmpty"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="ExpandAfter"
				IsNullable="true"
				DataType="GenItemNameType" />
		<PrimaryIndex Name="GelSpreadIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelspred_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="ExpandBetweenIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelspred_xbetween"
				Suffix="BetweenIdx" >
			<IndexCol Name="ExpandBetween" IsAscending="true" />
		</Index>
		<Index Name="ExpandBeforeIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelspred_xbefore"
				Suffix="BeforeIdx" >
			<IndexCol Name="ExpandBefore" IsAscending="true" />
		</Index>
		<Index Name="ExpandFirstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelspred_xfirst"
				Suffix="FirstIdx" >
			<IndexCol Name="ExpandFirst" IsAscending="true" />
		</Index>
		<Index Name="ExpandEachIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelspred_xeach"
				Suffix="EachIdx" >
			<IndexCol Name="ExpandEach" IsAscending="true" />
		</Index>
		<Index Name="ExpandLastIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelspred_xlast"
				Suffix="LastIdx" >
			<IndexCol Name="ExpandLast" IsAscending="true" />
		</Index>
		<Index Name="ExpandLoneIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelspred_xlone"
				Suffix="LoneIdx" >
			<IndexCol Name="ExpandLone" IsAscending="true" />
		</Index>
		<Index Name="ExpandEmptyIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelspred_xempty"
				Suffix="EmptyIdx" >
			<IndexCol Name="ExpandEmpty" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="gelspred_super"
				Suffix="SuperClass"
				FromIndex="GelSpreadIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.*;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		String					itemExpansion = null;
		ICFLibAnyObj			detailDef = null;
		MssCFGenContext			detailContext = null;
		int						idx;
		int						numItems = 0;
		int						totalItems = 0;
		List&lt;ICFLibAnyObj&gt;		detailList;

		ICFGenKbGenItemObj		itemBetween = null;
		ICFGenKbGenItemObj		itemBefore = null;
		ICFGenKbGenItemObj		itemAfter = null;
		ICFGenKbGenItemObj		itemEmpty = null;

		ICFGenKbGenItemObj		itemRule = null;

		String					failedBetween = null;
		String					failedBefore = null;
		String					failedFirst = null;
		String					failedEach = null;
		String					failedLast = null;
		String					failedAfter = null;
		String					failedLone = null;
		String					failedEmpty = null;

		String					expansion = null;
		MssCFGenContext			subContext = null;

		final String S_ProcName = &quot;CFGenKbGelSpreadObj.expand() &quot;;

		String				iteratorName = getRequiredIteratorName();
		String				bodyBetween = getOptionalExpandBetween();
		String				bodyBefore = getOptionalExpandBefore();
		String				bodyFirst = getOptionalExpandFirst();
		String				bodyEach = getRequiredExpandEach();
		String				bodyLast = getOptionalExpandLast();
		String				bodyAfter = getOptionalExpandAfter();
		String				bodyLone = getOptionalExpandLone();
		String				bodyEmpty = getOptionalExpandEmpty();

		MssCFEngine genEngine = genContext.getGenEngine();

		ICFGenKbGenItemObj genItem = genEngine.findContextItem(genContext, iteratorName );
		if( genItem == null ) {
			genEngine.getLog().message( &quot;Could not find iterator \&quot;&quot;
				+ iteratorName
				+ &quot;\&quot; attempting to expand \&quot;&quot;
				+ &quot;$$&quot; + getRequiredSourceText() + &quot;$$\&quot;&quot; );
			return( null );
		}

		if( ! ( genItem instanceof MssCFGenIteratorObj ) ) {
			genEngine.getLog().message( &quot;Context item \&quot;&quot;
				+ iteratorName
				+ &quot;\&quot; must be a MssCFGenIteratorObj, not a &quot;
				+ genItem.getClass().getPackage().getName() + &quot;.&quot; + genItem.getClass().getSimpleName()
				+ &quot;.  \&quot;&quot;
				+ &quot;$$&quot; + getRequiredSourceText() + &quot;$$&quot;
				+ &quot;\&quot; is invalid&quot; );
			return( null );
		}

		MssCFGenIteratorObj	iterator = (MssCFGenIteratorObj)genItem;

		String detailClassName;
		if (iterator.getDetailClass() != null) {
			detailClassName = iterator.getDetailClass().getRequiredName();
		}
		else {
			detailClassName = genEngine.getAnyClassName();
		}

		iteratorName = iterator.getRequiredName();

		if( ( iteratorName == null ) || ( 0 == iteratorName.length() ) ) {
			throw new RuntimeException( S_ProcName +  &quot;Iterator is not properly named&quot; );
		}

		if( ( detailClassName == null ) || ( 0 == detailClassName.length() ) ) {
			throw new RuntimeException( S_ProcName +  &quot;Iterator must specify a detail class name&quot; );
		}

		subContext = genEngine.getGenContextFactory().newGenContext( genContext.getGeneratingBuild(),
			genContext,
			detailClassName,
			null );
		subContext.setPrevContext( genContext );

		if( bodyBetween != null ) {
			failedBetween = &quot;$$&quot; + bodyBetween + &quot;$$&quot;;
			itemBetween = genEngine.findContextItem( genContext, bodyBetween );
			if( itemBetween == null ) {
				genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
					+ iteratorName
					+ &quot;\&quot; &quot;
					+ MssCFGelCompiler._SPREAD_BETWEEN
					+ &quot; \&quot;&quot;
					+ bodyBetween
					+ &quot;\&quot;&quot; );
			}
		}

		if( bodyBefore != null ) {
			failedBefore = &quot;$$&quot; + bodyBefore + &quot;$$&quot;;
			itemBefore = genEngine.findContextItem( genContext, bodyBefore );
			if( itemBefore == null ) {
				genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
					+ iteratorName
					+ &quot;\&quot; &quot;
					+ MssCFGelCompiler._ITERATOR_BEFORE
					+ &quot; \&quot;&quot;
					+ bodyBefore
					+ &quot;\&quot;&quot; );
			}
		}

		if( bodyAfter != null ) {
			failedAfter = &quot;$$&quot; + bodyAfter + &quot;$$&quot;;
			itemAfter = genEngine.findContextItem( genContext, bodyAfter );
			if( itemAfter == null ) {
				genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
					+ iteratorName
					+ &quot;\&quot; &quot;
					+ MssCFGelCompiler._ITERATOR_AFTER
					+ &quot; \&quot;&quot;
					+ bodyAfter
					+ &quot;\&quot;&quot; );
			}
		}

		if( bodyEmpty != null ) {
			failedEmpty = &quot;$$&quot; + bodyEmpty + &quot;$$&quot;;
			if( ! bodyEmpty.equals( MssCFGelCompiler._ITERATOR_EMPTY ) ) {
				itemEmpty = genEngine.findContextItem( genContext, bodyEmpty );
				if( itemEmpty == null ) {
					genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
						+ iteratorName
						+ &quot;\&quot; &quot;
						+ MssCFGelCompiler._ITERATOR_EMPTY
						+ &quot; \&quot;&quot;
						+ bodyEmpty
						+ &quot;\&quot;&quot; );
				}
			}
		}

		if( bodyFirst != null ) {
			failedFirst = &quot;$$&quot; + bodyFirst + &quot;$$&quot;;
		}

		if( bodyEach != null ) {
			failedEach = &quot;$$&quot; + bodyEach + &quot;$$&quot;;
		}

		if( bodyLast != null ) {
			failedLast = &quot;$$&quot; + bodyLast + &quot;$$&quot;;
		}

		if( bodyLone != null ) {
			failedLone = &quot;$$&quot; + bodyLone + &quot;$$&quot;;
		}

		detailList = iterator.getDetailList( genContext );
		if( detailList == null ) {
			genEngine.getLog().message( &quot;Could not get &quot;
				+ iteratorName
				+ &quot; detail object iteration.  \&quot;&quot;
				+ &quot;$$&quot; + getRequiredSourceText() + &quot;$$&quot;
				+ &quot;\&quot; is invalid&quot; );
			return( null );
		}

		expansion = &quot;&quot;;

		totalItems = detailList.size();

		if( totalItems &lt;= 0 ) {
			if( bodyEmpty != null ) {
				if( itemEmpty != null ) {
					itemExpansion = genContext.expandItemBody( itemEmpty );
					if( itemExpansion != null ) {
						expansion = expansion + itemExpansion;
					}
					else {
						expansion = expansion + failedEmpty;
					}
				}
				else if( ! bodyEmpty.equals( MssCFGelCompiler._ITERATOR_EMPTY ) ) {
					expansion = expansion + failedEmpty;
				}
			}
			else {
				genEngine.getLog().message( &quot;Expansion of iterator \&quot;&quot; + iteratorName + &quot;\&quot; returned an empty set&quot; );
			}
		}
		else {

			numItems = totalItems;
			while( numItems &gt; 0 ) {

				if( bodyBefore != null ) {
					if( itemBefore != null ) {
						itemExpansion = genContext.expandItemBody( itemBefore );
						if( itemExpansion != null ) {
							expansion = expansion + itemExpansion;
						}
						else {
							expansion = expansion + failedBefore;
						}
					}
					else {
						expansion = expansion + failedBefore;
					}
				}

				if( numItems == 1 ) {

					detailDef = detailList.get(0);
					detailContext = genEngine.getGenContextFactory().newGenContext( genContext.getGeneratingBuild(),
						genContext,
						detailDef.getGenDefName(),
						detailDef );
					detailContext.setPrevContext( genContext );

					if( bodyLone != null ) {
						itemRule = genEngine.findContextItem( detailContext, bodyLone );
						if( itemRule != null ) {
							itemExpansion = detailContext.expandItemBody( itemRule );
							if( itemExpansion != null ) {
								expansion = expansion + itemExpansion;
							}
							else {
								expansion = expansion + failedLone;
							}
						}
						else {
							genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
								+ iteratorName
								+ &quot;\&quot; &quot;
								+ MssCFGelCompiler._ITERATOR_LONE
								+ &quot; \&quot;&quot;
								+ bodyLone
								+ &quot;\&quot;&quot; );
							expansion = expansion + failedLone;
						}
					}
					else if( bodyFirst != null ) {
						itemRule = genEngine.findContextItem( detailContext, bodyFirst );
						if( itemRule != null ) {
							itemExpansion = detailContext.expandItemBody( itemRule );
							if( itemExpansion != null ) {
								expansion = expansion + itemExpansion;
							}
							else {
								expansion = expansion + failedFirst;
							}
						}
						else {
							genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
								+ iteratorName
								+ &quot;\&quot; &quot;
								+ MssCFGelCompiler._ITERATOR_FIRST
								+ &quot; \&quot;&quot;
								+ bodyFirst
								+ &quot;\&quot;&quot; );
							expansion = expansion + failedFirst;
						}
					}
					else if( bodyLast != null ) {
						itemRule = genEngine.findContextItem( detailContext, bodyLast );
						if( itemRule != null ) {
							itemExpansion = detailContext.expandItemBody( itemRule );
							if( itemExpansion != null ) {
								expansion = expansion + itemExpansion;
							}
							else {
								expansion = expansion + failedLast;
							}
						}
						else {
							genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
								+ iteratorName
								+ &quot;\&quot; &quot;
								+ MssCFGelCompiler._ITERATOR_LAST
								+ &quot; \&quot;&quot;
								+ bodyLast
								+ &quot;\&quot;&quot; );
							expansion = expansion + failedLast;
						}
					}
					else {
						itemRule = genEngine.findContextItem( detailContext, bodyEach );
						if( itemRule != null ) {
							itemExpansion = detailContext.expandItemBody( itemRule );
							if( itemExpansion != null ) {
								expansion = expansion + itemExpansion;
							}
							else {
								expansion = expansion + failedEach;
							}
						}
						else {
							genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
								+ iteratorName
								+ &quot;\&quot; &quot;
								+ MssCFGelCompiler._ITERATOR_EACH
								+ &quot; \&quot;&quot;
								+ bodyEach
								+ &quot;\&quot;&quot; );
							expansion = expansion + failedEach;
						}
					}
				}
				else {

					detailDef = detailList.get(0);
					detailContext = genEngine.getGenContextFactory().newGenContext( genContext.getGeneratingBuild(),
						genContext,
						detailDef.getGenDefName(),
						detailDef );
					detailContext.setPrevContext( genContext );

					if( bodyFirst != null ) {
						itemRule = genEngine.findContextItem( detailContext, bodyFirst );
						if( itemRule != null ) {
							itemExpansion = detailContext.expandItemBody( itemRule );
							if( itemExpansion != null ) {
								expansion = expansion + itemExpansion;
							}
							else {
								expansion = expansion + failedFirst;
							}
						}
						else {
							genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
								+ iteratorName
								+ &quot;\&quot; &quot;
								+ MssCFGelCompiler._ITERATOR_FIRST
								+ &quot; \&quot;&quot;
								+ bodyFirst
								+ &quot;\&quot;&quot; );
							expansion = expansion + failedFirst;
						}
					}
					else {
						itemRule = genEngine.findContextItem( detailContext, bodyEach );
						if( itemRule != null ) {
							itemExpansion = detailContext.expandItemBody( itemRule );
							if( itemExpansion != null ) {
								expansion = expansion + itemExpansion;
							}
							else {
								expansion = expansion + failedEach;
							}
						}
						else {
							genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
								+ iteratorName
								+ &quot;\&quot; &quot;
								+ MssCFGelCompiler._ITERATOR_EACH
								+ &quot; \&quot;&quot;
								+ bodyEach
								+ &quot;\&quot;&quot; );
							expansion = expansion + failedEach;
						}
					}

					for( idx = 1; idx &lt; numItems - 1; idx ++ ) {

						detailDef = detailList.get( idx );
						detailContext = genEngine.getGenContextFactory().newGenContext( genContext.getGeneratingBuild(),
							genContext,
							detailDef.getGenDefName(),
							detailDef );
						detailContext.setPrevContext( genContext );

						itemRule = genEngine.findContextItem( detailContext, bodyEach );
						if( itemRule != null ) {
							itemExpansion = detailContext.expandItemBody( itemRule );
							if( itemExpansion != null ) {
								expansion = expansion + itemExpansion;
							}
							else {
								expansion = expansion + failedEach;
							}
						}
						else {
							genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
								+ iteratorName
								+ &quot;\&quot; &quot;
								+ MssCFGelCompiler._ITERATOR_EACH
								+ &quot; \&quot;&quot;
								+ bodyEach
								+ &quot;\&quot;&quot; );
							expansion = expansion + failedEach;
						}
					}

					detailDef = detailList.get( numItems - 1 );
					detailContext = genEngine.getGenContextFactory().newGenContext( genContext.getGeneratingBuild(),
						genContext,
						detailDef.getGenDefName(),
						detailDef );
					detailContext.setPrevContext( genContext );

					if( bodyLast != null ) {
						itemRule = genEngine.findContextItem( detailContext, bodyLast );
						if( itemRule != null ) {
							itemExpansion = detailContext.expandItemBody( itemRule );
							if( itemExpansion != null ) {
								expansion = expansion + itemExpansion;
							}
							else {
								expansion = expansion + failedLast;
							}
						}
						else {
							genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
								+ iteratorName
								+ &quot;\&quot; &quot;
								+ MssCFGelCompiler._ITERATOR_LAST
								+ &quot; \&quot;&quot;
								+ bodyLast
								+ &quot;\&quot;&quot; );
							expansion = expansion + failedLast;
						}
					}
					else {
						itemRule = genEngine.findContextItem( detailContext, bodyEach );
						if( itemRule != null ) {
							itemExpansion = detailContext.expandItemBody( itemRule );
							if( itemExpansion != null ) {
								expansion = expansion + itemExpansion;
							}
							else {
								expansion = expansion + failedEach;
							}
						}
						else {
							genEngine.getLog().message( &quot;Could not find expansion item for iterator \&quot;&quot;
								+ iteratorName
								+ &quot;\&quot; &quot;
								+ MssCFGelCompiler._ITERATOR_EACH
								+ &quot; \&quot;&quot;
								+ bodyEach
								+ &quot;\&quot;&quot; );
							expansion = expansion + failedEach;
						}
					}
				}

				if( bodyAfter != null ) {
					if( itemAfter != null ) {
						itemExpansion = genContext.expandItemBody( itemAfter );
						if( itemExpansion != null ) {
							expansion = expansion + itemExpansion;
						}
						else {
							expansion = expansion + failedAfter;
						}
					}
					else {
						expansion = expansion + failedAfter;
					}
				}


				numItems --;

				if( numItems &gt; 0 ) {
					if( bodyBetween != null ) {
						if( itemBetween != null ) {
							itemExpansion = genContext.expandItemBody( itemBetween );
							if( itemExpansion != null ) {
								expansion = expansion + itemExpansion;
							}
							else {
								expansion = expansion + failedBetween;
							}
						}
						else {
							expansion = expansion + failedBetween;
						}
					}
				}
			}
		}

		return( expansion );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {
	std::string $SchemaName$GelSpreadObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );
		static const std::string S_IteratorName( "IteratorName" );
		static const std::string S_DetailClassName( "DetailClassName" );
		static const std::string S_BodyEach( "BodyEach" );
		static const std::string S_Dollar( "$$" );
		static const std::string S_DQuote( "\"" );
		static const std::string S_CouldNotFindExpansionItem( "Could not find expansion item for iterator \"" );
		static const std::string S_QuoteSpace( "\" " );
		static const std::string S_SpaceQuote( " \"" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		std::string iteratorName = getRequiredIteratorName();
		if( iteratorName.length() &lt;= 0 ) {
			throw cflib::CFLibEmptyArgumentException( CLASS_NAME, S_ProcName, 0, S_IteratorName );
		}

		std::string bodyEach = getRequiredExpandEach();
		if( bodyEach.length() &lt;= 0 ) {
			throw cflib::CFLibEmptyArgumentException( CLASS_NAME, S_ProcName, 0, S_BodyEach );
		}

		std::string emptyString;
		std::string itemExpansion;
		cflib::ICFLibAnyObj* detailDef = NULL;
		MssCFGenContext* detailContext = NULL;
		int idx;
		int numItems = 0;

		I$SchemaName$GenItemObj* itemBetween = NULL;
		I$SchemaName$GenItemObj* itemBefore = NULL;
		I$SchemaName$GenItemObj* itemAfter = NULL;
		I$SchemaName$GenItemObj* itemEmpty = NULL;

		I$SchemaName$GenItemObj* itemRule = NULL;

		std::string* failedBetween = NULL;
		std::string* failedBefore = NULL;
		std::string* failedFirst = NULL;
		std::string* failedEach = NULL;
		std::string* failedLast = NULL;
		std::string* failedAfter = NULL;
		std::string* failedLone = NULL;
		std::string* failedEmpty = NULL;

		const std::string* bodyBetween = getOptionalExpandBetweenReference();
		const std::string* bodyBefore = getOptionalExpandBeforeReference();
		const std::string* bodyFirst = getOptionalExpandFirstReference();
		const std::string* bodyLast = getOptionalExpandLastReference();
		const std::string* bodyAfter = getOptionalExpandAfterReference();
		const std::string* bodyLone = getOptionalExpandLoneReference();
		const std::string* bodyEmpty = getOptionalExpandEmptyReference();

		MssCFEngine* genEngine = genContext-&gt;getGenEngine();

	//	The genItem should be an MssCFGenIterator

		I$SchemaName$GenItemObj* genItem = genEngine-&gt;findContextItem( genContext, iteratorName );
		if( genItem == NULL ) {
			static const std::string S_CouldNotFindIterator( "Could not find iterator \"" );
			static const std::string S_Attempting( "\" attempting to expand \"" );
			std::string S_Msg( S_CouldNotFindIterator + iteratorName + S_Attempting + getRequiredSourceText() + S_DQuote );
			genEngine-&gt;getLog()-&gt;message( S_Msg );
			genContext-&gt;setExpansionIsNull();
			if( failedBefore != NULL ) {
				delete failedBefore;
				failedBefore = NULL;
			}
			if( failedFirst != NULL ) {
				delete failedFirst;
				failedFirst = NULL;
			}
			if( failedEach != NULL ) {
				delete failedEach;
				failedEach = NULL;
			}
			if( failedLast != NULL ) {
				delete failedLast;
				failedLast = NULL;
			}
			if( failedAfter != NULL ) {
				delete failedAfter;
				failedAfter = NULL;
			}
			if( failedLone != NULL ) {
				delete failedLone;
				failedLone = NULL;
			}
			if( failedEmpty != NULL ) {
				delete failedEmpty;
				failedEmpty = NULL;
			}
			return( emptyString );
		}

		MssCFGenIteratorObj* iterator = dynamic_cast&lt;MssCFGenIteratorObj*&gt;( genItem );
		if( iterator == NULL ) {
			static const std::string S_ContextItem( "Context item \"" );
			static const std::string S_MustBe( "\" must be an MssCFGenIteratorObj, not a \"" );
			static const std::string S_PeriodSpace( ". \"" );
			std::string S_Msg( S_ContextItem + iteratorName + S_MustBe + genItem-&gt;getClassName() + S_PeriodSpace + getRequiredSourceText() + S_DQuote );
			genEngine-&gt;getLog()-&gt;message( S_Msg );
			genContext-&gt;setExpansionIsNull();
			if( failedBefore != NULL ) {
				delete failedBefore;
				failedBefore = NULL;
			}
			if( failedFirst != NULL ) {
				delete failedFirst;
				failedFirst = NULL;
			}
			if( failedEach != NULL ) {
				delete failedEach;
				failedEach = NULL;
			}
			if( failedLast != NULL ) {
				delete failedLast;
				failedLast = NULL;
			}
			if( failedAfter != NULL ) {
				delete failedAfter;
				failedAfter = NULL;
			}
			if( failedLone != NULL ) {
				delete failedLone;
				failedLone = NULL;
			}
			if( failedEmpty != NULL ) {
				delete failedEmpty;
				failedEmpty = NULL;
			}
			return( emptyString );
		}

	//	Get the detailClassName

		std::string detailClassName;
		if( iterator-&gt;getDetailClass() != NULL ) {
			detailClassName = iterator-&gt;getDetailClass()-&gt;getRequiredName();
		}
		else {
			detailClassName = genEngine-&gt;getAnyClassName();
		}

		if( detailClassName.length() &lt;= 0 ) {
			if( failedBefore != NULL ) {
				delete failedBefore;
				failedBefore = NULL;
			}
			if( failedFirst != NULL ) {
				delete failedFirst;
				failedFirst = NULL;
			}
			if( failedEach != NULL ) {
				delete failedEach;
				failedEach = NULL;
			}
			if( failedLast != NULL ) {
				delete failedLast;
				failedLast = NULL;
			}
			if( failedAfter != NULL ) {
				delete failedAfter;
				failedAfter = NULL;
			}
			if( failedLone != NULL ) {
				delete failedLone;
				failedLone = NULL;
			}
			if( failedEmpty != NULL ) {
				delete failedEmpty;
				failedEmpty = NULL;
			}
			throw cflib::CFLibEmptyArgumentException( CLASS_NAME, S_ProcName, 0, S_DetailClassName );
		}

	//	Resolve the optional expansions

		if( bodyBetween != NULL ) {
			failedBetween = new std::string( S_Dollar + *bodyBetween + S_Dollar );
			itemBetween = genEngine-&gt;findContextItem( genContext, *bodyBetween );
			if( itemBetween == NULL ) {
				std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_SPREAD_BETWEEN + S_SpaceQuote + *bodyBetween + S_DQuote );
				genEngine-&gt;getLog()-&gt;message( S_Msg );
			}
		}

		if( bodyBefore != NULL ) {
			failedBefore = new std::string( S_Dollar + *bodyBefore + S_Dollar );
			itemBefore = genEngine-&gt;findContextItem( genContext, *bodyBefore );
			if( itemBefore == NULL ) {
				std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_BEFORE + S_SpaceQuote + *bodyBefore + S_DQuote );
				genEngine-&gt;getLog()-&gt;message( S_Msg );
			}
		}

		if( bodyAfter != NULL ) {
			failedAfter = new std::string( S_Dollar + *bodyAfter + S_Dollar );
			itemAfter = genEngine-&gt;findContextItem( genContext, *bodyAfter );
			if( itemAfter == NULL ) {
				std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_AFTER + S_SpaceQuote + *bodyAfter + S_DQuote );
				genEngine-&gt;getLog()-&gt;message( S_Msg );
			}
		}

		if( bodyEmpty != NULL ) {
			failedEmpty = new std::string( S_Dollar + *bodyEmpty + S_Dollar );
			if( *bodyEmpty != MssCFGelCompiler::_ITERATOR_EMPTY ) {
				itemEmpty = genEngine-&gt;findContextItem( genContext, *bodyEmpty );
				if( itemEmpty == NULL ) {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_EMPTY + S_SpaceQuote + *bodyEmpty + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
				}
			}
		}

		if( bodyFirst != NULL ) {
			failedFirst = new std::string( S_Dollar + *bodyFirst + S_Dollar );
		}

		failedEach = new std::string( S_Dollar + bodyEach + S_Dollar );

		if( bodyLast != NULL ) {
			failedLast = new std::string( S_Dollar + *bodyLast + S_Dollar );
		}

		if( bodyLone != NULL ) {
			failedLone = new std::string( S_Dollar + *bodyLone + S_Dollar );
		}

	//	Prepare to perform the expansions

		std::string expansion;

	//	Get the detailList

		std::vector&lt;cflib::ICFLibAnyObj*&gt;* detailList = iterator-&gt;getDetailList( genContext );
		if( detailList == NULL ) {
			static const std::string S_CouldNotGet( "Could not get " );
			static const std::string S_DetailIteration( " detail object iteration.  \"$$" );
			static const std::string S_IsInvalid( "$$\" is invalid" );
			std::string S_Msg( S_CouldNotGet + iteratorName + S_DetailIteration + getRequiredSourceText() + S_IsInvalid );
			genEngine-&gt;getLog()-&gt;message( S_Msg );
			genContext-&gt;setExpansionIsNull();
			if( failedBefore != NULL ) {
				delete failedBefore;
				failedBefore = NULL;
			}
			if( failedFirst != NULL ) {
				delete failedFirst;
				failedFirst = NULL;
			}
			if( failedEach != NULL ) {
				delete failedEach;
				failedEach = NULL;
			}
			if( failedLast != NULL ) {
				delete failedLast;
				failedLast = NULL;
			}
			if( failedAfter != NULL ) {
				delete failedAfter;
				failedAfter = NULL;
			}
			if( failedLone != NULL ) {
				delete failedLone;
				failedLone = NULL;
			}
			if( failedEmpty != NULL ) {
				delete failedEmpty;
				failedEmpty = NULL;
			}
			return( emptyString );
		}

	//	If a BEFORE item is provided, we always expand it using the CURRENT
	//	context, not a sub-context.

		if( bodyBefore != NULL ) {
			if( itemBefore != NULL ) {
				itemExpansion = genContext-&gt;expandItemBody( itemBefore );
				if( ! genContext-&gt;isExpansionNull() ) {
					expansion.append( itemExpansion );
				}
				else {
					expansion.append( *failedBefore );
				}
			}
			else {
				expansion.append( *failedBefore );
			}
			genContext-&gt;clearExpansionIsNull();
		}

	//	How we perform the expansion depends on what iterator limbs
	//	have been specified and on the number of items to process.

		numItems = detailList-&gt;size();

		//	If the detail set is empty, expand EMPTY if it&apos;s provided

		if( numItems == 0 ) {
			if( bodyEmpty != NULL ) {
				if( itemEmpty != NULL ) {
					itemExpansion = genContext-&gt;expandItemBody( itemEmpty );
					if( ! genContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedEmpty );
					}
				}
				else if( *bodyEmpty != MssCFGelCompiler::_ITERATOR_EMPTY ) {
					expansion.append( *failedEmpty );
				}
				genContext-&gt;clearExpansionIsNull();
			}
			else {
				static const std::string S_ExpansionOfIterator( "Expansion of iterator \"" );
				static const std::string S_ReturnedAnEmptySet( "\" returned an empty set" );
				std::string S_Msg( S_ExpansionOfIterator + iteratorName + S_ReturnedAnEmptySet );
				genEngine-&gt;getLog()-&gt;message( S_Msg );
			}
		}

	//	If the detail set has one item, preferentially expand one of
	//	LONE, LAST, FIRST, or EACH limb

		else if( numItems == 1 ) {

			detailDef = detailList-&gt;front();
			detailContext = genEngine-&gt;getGenContextFactory()-&gt;newGenContext( genContext-&gt;getGeneratingBuild(),
				genContext,
				detailDef-&gt;getGenDefName(),
				detailDef );
			detailContext-&gt;setPrevContext( genContext );

			if( bodyLone != NULL ) {
				itemRule = genEngine-&gt;findContextItem( detailContext, *bodyLone );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedLone );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_LONE + S_SpaceQuote + *bodyLone + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedLone );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			else if( bodyFirst != NULL ) {
				itemRule = genEngine-&gt;findContextItem( detailContext, *bodyFirst );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedFirst );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_FIRST + S_SpaceQuote + *bodyFirst + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedFirst );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			else if( bodyLast != NULL ) {
				itemRule = genEngine-&gt;findContextItem( detailContext, *bodyLast );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedLast );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_LAST + S_SpaceQuote + *bodyLast + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedLast );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			else {
				itemRule = genEngine-&gt;findContextItem( detailContext, bodyEach );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedEach );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_EACH + S_SpaceQuote + bodyEach + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedEach );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			while( ( detailContext != NULL ) &amp;&amp; ( detailContext != genContext ) ) {
				detailContext = detailContext-&gt;release();
			}
			detailContext = NULL;
		}
		else {

	//	If the detail set has n items:

	//		The first item is expanded by FIRST or EACH

			detailDef = detailList-&gt;front();
			detailContext = genEngine-&gt;getGenContextFactory()-&gt;newGenContext( genContext-&gt;getGeneratingBuild(),
				genContext,
				detailDef-&gt;getGenDefName(),
				detailDef );
			detailContext-&gt;setPrevContext( genContext );

			if( bodyFirst != NULL ) {
				itemRule = genEngine-&gt;findContextItem( detailContext, *bodyFirst );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedFirst );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_FIRST + S_SpaceQuote + *bodyFirst + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedFirst );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			else {
				itemRule = genEngine-&gt;findContextItem( detailContext, bodyEach );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedEach );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_EACH + S_SpaceQuote + bodyEach + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedEach );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			while( ( detailContext != NULL ) &amp;&amp; ( detailContext != genContext ) ) {
				detailContext = detailContext-&gt;release();
			}
			detailContext = NULL;

	//		The middle items are always expanded by EACH

			auto iterItems = detailList-&gt;begin();
			iterItems ++;
			for( idx = 1; idx &lt; numItems - 1; idx ++ ) {

				detailDef = *iterItems;
				iterItems ++;

				detailContext = genEngine-&gt;getGenContextFactory()-&gt;newGenContext( genContext-&gt;getGeneratingBuild(),
					genContext,
					detailDef-&gt;getGenDefName(),
					detailDef );
				detailContext-&gt;setPrevContext( genContext );

				itemRule = genEngine-&gt;findContextItem( detailContext, bodyEach );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedEach );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_EACH + S_SpaceQuote + bodyEach + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedEach );
				}
				detailContext-&gt;clearExpansionIsNull();
				while( ( detailContext != NULL ) &amp;&amp; ( detailContext != genContext ) ) {
					detailContext = detailContext-&gt;release();
				}
				detailContext = NULL;
			}

	//		The last item is expanded by LAST or EACH

			detailDef = detailList-&gt;back();
			detailContext = genEngine-&gt;getGenContextFactory()-&gt;newGenContext( genContext-&gt;getGeneratingBuild(),
				genContext,
				detailDef-&gt;getGenDefName(),
				detailDef );
			detailContext-&gt;setPrevContext( genContext );

			if( bodyLast != NULL ) {
				itemRule = genEngine-&gt;findContextItem( detailContext, *bodyLast );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedLast );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_LAST + S_SpaceQuote + *bodyBefore + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedLast );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			else {
				itemRule = genEngine-&gt;findContextItem( detailContext, bodyEach );
				if( itemRule != NULL ) {
					itemExpansion = detailContext-&gt;expandItemBody( itemRule );
					if( ! detailContext-&gt;isExpansionNull() ) {
						expansion.append( itemExpansion );
					}
					else {
						expansion.append( *failedEach );
					}
				}
				else {
					std::string S_Msg( S_CouldNotFindExpansionItem + iteratorName + S_QuoteSpace + MssCFGelCompiler::_ITERATOR_EACH + S_SpaceQuote + bodyEach + S_DQuote );
					genEngine-&gt;getLog()-&gt;message( S_Msg );
					expansion.append( *failedEach );
				}
				detailContext-&gt;clearExpansionIsNull();
			}
			while( ( detailContext != NULL ) &amp;&amp; ( detailContext != genContext ) ) {
				detailContext = detailContext-&gt;release();
			}
			detailContext = NULL;
		}

	//	If an AFTER item is provided, we always expand it using the CURRENT
	//	context, not a sub-context.

		if( bodyAfter != NULL ) {
			if( itemAfter != NULL ) {
				itemExpansion = genContext-&gt;expandItemBody( itemAfter );
				if( ! genContext-&gt;isExpansionNull() ) {
					expansion.append( itemExpansion );
				}
				else {
					expansion.append( *failedAfter );
				}
			}
			else {
				expansion.append( *failedAfter );
			}
			genContext-&gt;clearExpansionIsNull();
		}

	//	Release the detail context

		while( ( detailContext != NULL ) &amp;&amp; ( detailContext != genContext ) ) {
			detailContext = detailContext-&gt;release();
		}
		detailContext = NULL;

	//	Delete the detail list

		if( detailList != NULL ) {
			delete detailList;
			detailList = NULL;
		}

	//	Release local allocations

		if( failedBefore != NULL ) {
			delete failedBefore;
			failedBefore = NULL;
		}
		if( failedFirst != NULL ) {
			delete failedFirst;
			failedFirst = NULL;
		}
		if( failedEach != NULL ) {
			delete failedEach;
			failedEach = NULL;
		}
		if( failedLast != NULL ) {
			delete failedLast;
			failedLast = NULL;
		}
		if( failedAfter != NULL ) {
			delete failedAfter;
			failedAfter = NULL;
		}
		if( failedLone != NULL ) {
			delete failedLone;
			failedLone = NULL;
		}
		if( failedEmpty != NULL ) {
			delete failedEmpty;
			failedEmpty = NULL;
		}

	//	Return the cumulative results of the expansion

		genContext-&gt;clearExpansionIsNull();
		return( expansion );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelSpreadEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelPop"
			TableClassCode="a919"
			DbName="gelpop"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				DataType="GelCacheIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="GoalTypeName"
				IsNullable="false"
				DataType="GenItemNameType" />
		<TableCol Name="RemainderTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="RemainderGelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				GenerateId="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="RemainderInstId"
				Label="Remainder Instruction Id"
				IsNullable="true"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GelPopIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelpop_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GelPopRemainderInstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelpop_xremainder"
				Suffix="RemainderIdx" >
			<IndexCol Name="RemainderTenantId" IsAscending="true" />
			<IndexCol Name="RemainderGelCacheId" IsAscending="true" />
			<IndexCol Name="RemainderInstId" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="gelpop_super"
				Suffix="SuperClass"
				FromIndex="GelPopIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		throw new RuntimeException( &quot;$SchemaName$GelPopObj.expand() must be specialized by the pop implementation&quot; );
	}
</CafeObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {
	std::string $SchemaName$GelPopObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );
		static const std::string S_Msg( "Implementation must be overridden by GelPop specialization" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		throw cflib::CFLibMustOverrideException( CLASS_NAME, S_ProcName, S_Msg );
	}
</CPlusObjImplementation>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelPopEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );
		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelPrefixLine"
			TableClassCode="a91a"
			DbName="gelprefix"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				DataType="GelCacheIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="PrefixName"
				IsNullable="false"
				DataType="GenItemNameType" />
		<TableCol Name="RemainderTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="RemainderGelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				GenerateId="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="RemainderInstId"
				Label="Remainder Instruction Id"
				IsNullable="true"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GelPrefixLineIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelprefix_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GelPrefixLineRemainderInstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelprefix_xremainder"
				Suffix="RemainderIdx" >
			<IndexCol Name="RemainderTenantId" IsAscending="true" />
			<IndexCol Name="RemainderGelCacheId" IsAscending="true" />
			<IndexCol Name="RemainderInstId" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="gelprefix_super"
				Suffix="SuperClass"
				FromIndex="GelPrefixLineIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.*;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		final String S_ProcName = &quot;$SchemaName$GelPrefixLineObj.expand() &quot;;

		String prefixName = getRequiredPrefixName();
		if( ( prefixName == null ) || ( prefixName.length() == 0 ) ) {
			throw new RuntimeException( S_ProcName + &quot;Required PrefixName was not specified&quot; );
		}

		String prefixStrValue;
		I$SchemaName$GenItemObj prefixItem = genContext.getGenEngine().findContextItem(genContext, prefixName );
		if( prefixItem == null ) {
			throw new RuntimeException( S_ProcName + &quot;Could not resolve prefix \&quot;&quot; + prefixName + &quot;\&quot;, $$&quot; + getRequiredSourceText() + &quot;$$ is invalid&quot; );
		}

		if( prefixItem instanceof MssCFGenFileObj ) {
			prefixStrValue = ((MssCFGenFileObj)prefixItem).expandBody( genContext );
		}
		else if( prefixItem instanceof MssCFGenRuleObj ) {
			prefixStrValue = ((MssCFGenRuleObj)prefixItem).expandBody( genContext );
		}
		else if (prefixItem instanceof MssCFGenTruncObj)
		{
			prefixStrValue = ((MssCFGenTruncObj)prefixItem).expandBody( genContext );
		}
		else if (prefixItem instanceof MssCFGenBindObj)
		{
			prefixStrValue = ((MssCFGenBindObj)prefixItem).expandBody( genContext );
		}
		else if( prefixItem instanceof MssCFGenReferenceObj ) {
			throw new RuntimeException(S_ProcName + &quot;Cannot expand reference &quot; + prefixItem.getRequiredName() + &quot; directly&quot;);
		}
		else if( prefixItem instanceof MssCFGenIteratorObj ) {
			prefixStrValue = ((MssCFGenIteratorObj)prefixItem).expandBody( genContext );
		}
		else {
			throw new RuntimeException( S_ProcName +  &quot;Unsupported generation item class&quot; );
		}

		if( prefixStrValue == null ) {
			prefixStrValue = &quot;$$&quot; + prefixName + &quot;$$&quot;;
		}

		I$SchemaName$GelInstructionObj remainder = getOptionalLookupRemainder();
		if( remainder == null ) {
			throw new RuntimeException( S_ProcName + &quot;Remainder of macro was not properly compiled&quot; );
		}

		String body = remainder.expand( genContext );
		if (body == null) {
			body = &quot;$$&quot; + remainder.getRequiredSourceText() + &quot;$$&quot;;
		}

		String retval = prefixStrValue + body.replace(&quot;\n&quot;, &quot;\n&quot; + prefixStrValue );

		return( retval );
	}
</CafeObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	std::string $SchemaName$GelPrefixLineObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );
		static const std::string S_PrefixName( "PrefixName" );
		static const std::string S_Dollar( "$$" );
		static const std::string S_DQuote( "\"" );
		static const std::string S_DQuoteCommaSpaceDQuote( "\", \"" );
		static const std::string S_CouldNotResolvePrefix( "Could not resolve prefix \"" );
		static const std::string S_ExpectedPrefixItemClass( "Expected prefix item to be one of MssCFGenFileObj, MssCFGenRuleObj, MssCFGenTruncObj, MssCFGenBindObj, MssCFGenReferenceObj, or MssCFGenIterator, not " );
		static const std::string S_RemainderNotProperlyCompiled( "Remainder of macro was not properly compiled" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		std::string prefixName = getRequiredPrefixName();
		if( prefixName.length() &lt;= 0 ) {
			throw cflib::CFLibEmptyArgumentException( CLASS_NAME, S_ProcName, 0, S_PrefixName );
		}

		std::string emptyString;
		std::string prefixStrValue;
		I$SchemaName$GenItemObj* prefixItem = genContext-&gt;getGenEngine()-&gt;findContextItem( genContext, prefixName );
		if( prefixItem == NULL ) {
			std::string S_Msg( S_CouldNotResolvePrefix + prefixName + S_DQuoteCommaSpaceDQuote + getRequiredSourceText() + S_DQuote );
			genContext-&gt;getGenEngine()-&gt;getLog()-&gt;message( S_Msg );
			genContext-&gt;setExpansionIsNull();
			return( emptyString );
		}

		MssCFGenFileObj* genFileItem = dynamic_cast&lt;MssCFGenFileObj*&gt;( prefixItem );
		if( genFileItem != NULL ) {
			prefixStrValue = genFileItem-&gt;expandBody( genContext );
		}
		else {
			MssCFGenRuleObj* genRuleItem = dynamic_cast&lt;MssCFGenRuleObj*&gt;( prefixItem );
			if( genRuleItem != NULL ) {
				prefixStrValue = genRuleItem-&gt;expandBody( genContext );
			}
			else {
				MssCFGenTruncObj* genTruncItem = dynamic_cast&lt;MssCFGenTruncObj*&gt;( prefixItem );
				if( genTruncItem != NULL ) {
					prefixStrValue = genTruncItem-&gt;expandBody( genContext );
				}
				else {
					MssCFGenBindObj* genBindItem = dynamic_cast&lt;MssCFGenBindObj*&gt;( prefixItem );
					if( genBindItem != NULL ) {
						prefixStrValue = genBindItem-&gt;expandBody( genContext );
					}
					else {
						MssCFGenReferenceObj* genReferenceItem = dynamic_cast&lt;MssCFGenReferenceObj*&gt;( prefixItem );
						if( genReferenceItem != NULL ) {
							prefixStrValue = genReferenceItem-&gt;expandBody( genContext );
						}
						else {
							MssCFGenIteratorObj* genIteratorItem = dynamic_cast&lt;MssCFGenIteratorObj*&gt;( prefixItem );
							if( genIteratorItem != NULL ) {
								prefixStrValue = genIteratorItem-&gt;expandBody( genContext );
							}
							else {
								std::string S_Msg( S_ExpectedPrefixItemClass + prefixItem-&gt;getClassName() );
								throw cflib::CFLibUnsupportedClassException( CLASS_NAME, S_ProcName, S_Msg );
							}
						}
					}
				}
			}
		}

		if( genContext-&gt;isExpansionNull() ) {
			prefixStrValue = S_DQuote + S_Dollar + prefixName + S_Dollar + S_DQuote;
		}

		I$SchemaName$GelInstructionObj* remainder = getOptionalLookupRemainder();
		if( remainder == NULL ) {
			throw cflib::CFLibRuntimeException( CLASS_NAME, S_ProcName, S_RemainderNotProperlyCompiled );
		}

		std::string body = remainder-&gt;expand( genContext );
		if( genContext-&gt;isExpansionNull() ) {
			body = S_Dollar + prefixName + S_Dollar;
		}

		// Note this is a string replacement, not a character replacement

		static const std::string S_Newline( "\n" );
		std::string::size_type lenNewline = S_Newline.length();

		const std::string prefixStrWithNewline( S_Newline + prefixStrValue );
		std::string::size_type lenReplacement = prefixStrWithNewline.length();

		std::string::size_type offset = 0;
		std::string::size_type foundNewlineAt = body.find( S_Newline, offset );
		while( foundNewlineAt != std::string::npos ) {
			body = body.replace( foundNewlineAt, lenNewline, prefixStrWithNewline );
			offset = foundNewlineAt + lenReplacement;
			foundNewlineAt = body.find( S_Newline, offset );
		}

		return( body );
	}
</CPlusObjImplementation>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelPrefixLineEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelReference"
			TableClassCode="a91b"
			DbName="gelrefer"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				DataType="GelCacheIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="ReferenceName"
				IsNullable="false"
				DataType="GenItemNameType" />
		<TableCol Name="RemainderTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="RemainderGelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				GenerateId="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="RemainderInstId"
				Label="Remainder Instruction Id"
				IsNullable="true"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GelReferenceIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelrefer_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GelReferenceRemainderInstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelrefer_xremainder"
				Suffix="RemainderIdx" >
			<IndexCol Name="RemainderTenantId" IsAscending="true" />
			<IndexCol Name="RemainderGelCacheId" IsAscending="true" />
			<IndexCol Name="RemainderInstId" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="gelrefer_super"
				Suffix="SuperClass"
				FromIndex="GelReferenceIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.*;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		String retval;
		final String S_ProcName = &quot;$SchemaName$GelReference.expand() &quot;;
		String referenceName = getRequiredReferenceName();

		String generatingBuild = genContext.getGeneratingBuild();

		I$SchemaName$GenItemObj genItem = genContext.getGenEngine().findContextItem(genContext, referenceName );
		if( genItem == null ) {
			genContext.getGenEngine().getLog().message( &quot;Could not resolve reference method \&quot;&quot;
				+ referenceName
				+ &quot;\&quot;. \&quot;&quot;
				+ &quot;$$&quot; + getRequiredSourceText() + &quot;$$&quot;
				+ &quot;\&quot; is invalid&quot; );
			return( null );
		}

		if( ! ( genItem instanceof MssCFGenReferenceObj ) ) {
			genContext.getGenEngine().getLog().message( &quot;Resolution of reference method \&quot;&quot;
				+ referenceName
				+ &quot;\&quot; returned a &quot;
				+ genItem.getClass().getPackage().getName() + &quot;.&quot; + genItem.getClass().getSimpleName()
				+ &quot;, not a MssCFGenReferenceObj. \&quot;&quot;
				+ &quot;$$&quot; + getRequiredSourceText() + &quot;$$&quot;
				+ &quot;\&quot; is invalid&quot; );
			return( null );
		}

		MssCFGenReferenceObj reference = (MssCFGenReferenceObj)genItem;

		ICFLibAnyObj refDef = reference.dereference( genContext );
		if( refDef == null ) {
			genContext.getGenEngine().getLog().message( &quot;Resolution of reference \&quot;&quot;
				+ referenceName
				+ &quot;\&quot; returned null. \&quot;&quot;
				+ &quot;$$&quot; + getRequiredSourceText() + &quot;$$&quot;
				+ &quot;\&quot; is invalid&quot; );
			return( null );
		}

		MssCFGenContext refContext = genContext.buildRefContext( generatingBuild, refDef );
		if( refContext == null ) {
			throw new RuntimeException( S_ProcName +  &quot;buildRefContext() failed&quot; );
		}

		I$SchemaName$GelInstructionObj remainder = getOptionalLookupRemainder();

		String expansion;
		if( remainder == null ) {
			expansion = &quot;&quot;;
		}
		else {
			expansion = remainder.expand( refContext );
		}

		return( expansion );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>


		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	std::string $SchemaName$GelReferenceObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );
		static const std::string S_ReferenceName( "ReferenceName" );
		static const std::string S_Dollar( "$$" );
		static const std::string S_DQuote( "\"" );
		static const std::string S_DQuoteCommaSpaceDQuote( "\", \"" );
		static const std::string S_CouldNotResolveReference( "Could not resolve reference \"" );
		static const std::string S_ExpectedReferenceItemClass( "Expected reference item to be MssCFGenReferenceObj, not " );
		static const std::string S_DereferenceFailed( "Resolution of reference \"" );
		static const std::string S_RemainderNotProperlyCompiled( "Remainder of macro was not properly compiled" );
		static const std::string S_BuildRefContextFailed( "buildRefContext() failed" );
		static const std::string S_ReturnedNULL( " returned NULL, \"" );
		static const std::string S_IsInvalid( "\" is invalid" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		std::string referenceName = getRequiredReferenceName();
		if( referenceName.length() &lt;= 0 ) {
			throw cflib::CFLibEmptyArgumentException( CLASS_NAME, S_ProcName, 0, S_ReferenceName );
		}

		std::string emptyString;
		I$SchemaName$GenItemObj* referenceItem = genContext-&gt;getGenEngine()-&gt;findContextItem( genContext, referenceName );
		if( referenceItem == NULL ) {
			std::string S_Msg( S_CouldNotResolveReference + referenceName + S_DQuoteCommaSpaceDQuote + getRequiredSourceText() + S_DQuote );
			genContext-&gt;getGenEngine()-&gt;getLog()-&gt;message( S_Msg );
			genContext-&gt;setExpansionIsNull();
			return( emptyString );
		}

		std::string expansion;

		MssCFGenReferenceObj* genReferenceItem = dynamic_cast&lt;MssCFGenReferenceObj*&gt;( referenceItem );
		if( genReferenceItem != NULL ) {
			cflib::ICFLibAnyObj* refDef = genReferenceItem-&gt;dereference( genContext );
			if( refDef == NULL ) {
				std::string S_Msg( S_DereferenceFailed + referenceName + S_ReturnedNULL + getRequiredSourceText() + S_IsInvalid );
				genContext-&gt;getGenEngine()-&gt;getLog()-&gt;message( S_Msg );
				genContext-&gt;setExpansionIsNull();
				return( emptyString );
			}

			MssCFGenContext* refContext = genContext-&gt;buildRefContext( refDef );
			if( refContext == NULL ) {
				throw cflib::CFLibRuntimeException( CLASS_NAME, S_ProcName, S_BuildRefContextFailed );
			}

			I$SchemaName$GelInstructionObj* remainder = getOptionalLookupRemainder();
			if( remainder != NULL ) {
				expansion = remainder-&gt;expand( refContext );
				genContext-&gt;setExpansionIsNull( refContext-&gt;isExpansionNull() );
			}

			while( ( refContext != NULL ) &amp;&amp; ( refContext != genContext ) ) {
				refContext = refContext->release();
			}
		}
		else {
			std::string S_Msg( S_ExpectedReferenceItemClass + referenceItem-&gt;getClassName() );
			genContext-&gt;getGenEngine()-&gt;getLog()-&gt;message( S_Msg );
			genContext-&gt;setExpansionIsNull();
			return( emptyString );
		}

		return( expansion );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelReferenceEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelCall"
			TableClassCode="a91c"
			DbName="gelcall"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				DataType="GelCacheIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="SeqInstTenantId"
				Label="Sequence Tenant Id"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="SeqInstGelCacheId"
				Label="Sequence GelCache Id"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="SeqInstId"
				Label="Sequence Instruction Id"
				IsNullable="true"
				DataType="GelInstructionIdGen" />
		<TableCol Name="CallInstTenantId"
				Label="Call Instruction Tenant Id"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="CallInstGelCacheId"
				Label="Call Instruction GelCache Id"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="CallInstId"
				Label="Call Instruction Id"
				IsNullable="true"
				DataType="GelInstructionIdGen" />
		<TableCol Name="PrevInstTenantId"
				Label="Prev Instruction Tenant Id"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="PrevInstGelCacheId"
				Label="Prev Instruction GelCache Id"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="PrevInstGelInstId"
				Label="Prev Instruction Id"
				IsNullable="true"
				DataType="GelInstructionIdGen" />
		<TableCol Name="NextInstTenantId"
				Label="Next Instruction Tenant Id"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="NextInstGelCacheId"
				Label="Next Instruction GelCache Id"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="NextInstGelInstId"
				Label="Next Instruction Id"
				IsNullable="true"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GelCallIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelcall_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GelCallCacheIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelcall_xcache"
				Suffix="CacheIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
		</Index>
		<Index Name="GelCallSequenceIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelcall_xseq"
				Suffix="SeqIdx" >
			<IndexCol Name="SeqInstTenantId" IsAscending="true" />
			<IndexCol Name="SeqInstGelCacheId" IsAscending="true" />
			<IndexCol Name="SeqInstId" IsAscending="true" />
		</Index>
		<Index Name="GelCallCallInstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelcall_xcall"
				Suffix="CallInstIdx" >
			<IndexCol Name="CallInstTenantId" IsAscending="true" />
			<IndexCol Name="CallInstGelCacheId" IsAscending="true" />
			<IndexCol Name="CallInstId" IsAscending="true" />
		</Index>
		<Index Name="GelCallPrevInstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelcall_xprev"
				Suffix="PrevInstIdx" >
			<IndexCol Name="PrevInstTenantId" IsAscending="true" />
			<IndexCol Name="PrevInstGelCacheId" IsAscending="true" />
			<IndexCol Name="PrevInstGelInstId" IsAscending="true" />
		</Index>
		<Index Name="GelCallNextInstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelcall_xnext"
				Suffix="NextInstIdx" >
			<IndexCol Name="NextInstTenantId" IsAscending="true" />
			<IndexCol Name="NextInstGelCacheId" IsAscending="true" />
			<IndexCol Name="NextInstGelInstId" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="gelcall_super"
				Suffix="SuperClass"
				FromIndex="GelCallIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		final String S_ProcName = "expand";
		final String S_GenContext = "genContext";

		if( genContext == null ) {
			throw new CFLibNullArgumentException( getClass(), S_ProcName, 1, S_GenContext );
		}

		String subExpansion;

		I$SchemaName$GelInstructionObj called = getOptionalLookupCallInst();
		if( called != null ) {
			subExpansion = called.expand( genContext );
			if( subExpansion == null ) {
				subExpansion = "$$" + called.getRequiredSourceText() + "$$";
			}
		}
		else {
			subExpansion = "$$" + getRequiredSourceText() + "$$";
		}

		return( subExpansion );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	std::string $SchemaName$GelCallObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		std::string emptyString;
		std::string expansion;
		std::string subExpansion;

		I$SchemaName$GelInstructionObj* called = getOptionalLookupCallInst();
		if( called != NULL ) {
			subExpansion = called-&gt;expand( genContext );
			if( genContext-&gt;isExpansionNull() ) {
				subExpansion = "$$" + called-&gt;getRequiredSourceText() + "$$";
			}
		}
		else {
			subExpansion = "$$" + getRequiredSourceText() + "$$";
		}

		expansion.append( subExpansion );
		genContext-&gt;clearExpansionIsNull();

		return( expansion );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelCallEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelSequence"
			TableClassCode="a91d"
			DbName="gelsequence"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				DataType="GelCacheIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="FirstInstTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="FirstInstGelCacheId"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="FirstInstId"
				Label="First Instruction in the chain"
				IsNullable="true"
				DataType="GelInstructionIdGen" />
		<TableCol Name="LastInstTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="LastInstGelCacheId"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="LastInstId"
				Label="Last Instruction in the chain"
				IsNullable="true"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GelSequenceIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelsequence_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GelSequenceFirstInstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelsequence_xfirst"
				Suffix="FirstInstIdx" >
			<IndexCol Name="FirstInstTenantId" IsAscending="true" />
			<IndexCol Name="FirstInstGelCacheId" IsAscending="true" />
			<IndexCol Name="FirstInstId" IsAscending="true" />
		</Index>
		<Index Name="GelSequenceLastInstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelsequence_xlast"
				Suffix="LastInstIdx" >
			<IndexCol Name="LastInstTenantId" IsAscending="true" />
			<IndexCol Name="LastInstGelCacheId" IsAscending="true" />
			<IndexCol Name="LastInstId" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="gelsequence_super"
				Suffix="SuperClass"
				FromIndex="GelSequenceIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public void addCalledInstruction( I$SchemaName$GelCacheObj gelCache, I$SchemaName$GelInstructionObj calledInstruction ) {
		I$SchemaName$GelCallObj newCallObj = schema.getGelCallTableObj().newInstance();
		I$SchemaName$GelCallEditObj editNewCall = (I$SchemaName$GelCallEditObj)( newCallObj.beginEdit() );
		editNewCall.setRequiredOwnerTenant( getRequiredOwnerTenant() );
		editNewCall.setRequiredContainerGelCache( getRequiredContainerGelCache() );
		editNewCall.setOptionalParentSeqInst( this );
		editNewCall.setOptionalLookupCallInst( calledInstruction );
		editNewCall.setOptionalLookupNextInst( null );
		I$SchemaName$GelCallObj lastObj = getOptionalLookupLastInst();
		editNewCall.setOptionalLookupPrevInst( lastObj );
		newCallObj = (I$SchemaName$GelCallObj)( editNewCall.create() );
		editNewCall = null;
		I$SchemaName$GelSequenceEditObj editMe = (I$SchemaName$GelSequenceEditObj)beginEdit();
		if( lastObj != null ) {
			I$SchemaName$GelCallEditObj editLast = (I$SchemaName$GelCallEditObj)( lastObj.beginEdit() );
			editLast.setOptionalLookupNextInst( newCallObj );
			editLast.update();
			editLast = null;
		}
		else {
			editMe.setOptionalLookupFirstInst( newCallObj );
		}
		editMe.setOptionalLookupLastInst( newCallObj );
		editMe.update();
		editMe = null;
	}

	public String expand( MssCFGenContext genContext ) {
		final String S_ProcName = "expand";
		final String S_GenContext = "genContext";

		if( genContext == null ) {
			throw new CFLibNullArgumentException( getClass(), S_ProcName, 1, S_GenContext );
		}

		StringBuffer expansion = new StringBuffer();
		String subExpansion;

		// Preload the instructions to avoid a read storm
		genContext.getGenEngine().getGelCallTableObj().readGelCallBySeqIdx( getRequiredTenantId(), getRequiredGelCacheId(), getRequiredGelInstId() );

		I$SchemaName$GelInstructionObj nextCalled;
		I$SchemaName$GelCallObj nextCall = getOptionalLookupFirstInst();
		while( nextCall != null ) {
			nextCalled = nextCall.getOptionalLookupCallInst();
			if( nextCalled != null ) {
				subExpansion = nextCalled.expand( genContext );
				if( subExpansion == null ) {
					subExpansion = "$$" + nextCalled.getRequiredSourceText() + "$$";
				}
				expansion.append( subExpansion );
			}
			nextCall = nextCall.getOptionalLookupNextInst();
		}

		return( expansion.toString() );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );
		virtual void addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;
		virtual void addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	void $SchemaName$GelSequenceObj::addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction ) {
		I$SchemaName$GelCallObj* newCallObj = schema-&gt;getGelCallTableObj()-&gt;newInstance();
		I$SchemaName$GelCallEditObj* editNewCall = dynamic_cast&lt;I$SchemaName$GelCallEditObj*&gt;( newCallObj-&gt;beginEdit() );
		editNewCall-&gt;setRequiredOwnerTenant( getRequiredOwnerTenant() );
		editNewCall-&gt;setRequiredContainerGelCache( getRequiredContainerGelCache() );
		editNewCall-&gt;setOptionalParentSeqInst( this );
		editNewCall-&gt;setOptionalLookupCallInst( calledInstruction );
		editNewCall-&gt;setOptionalLookupNextInst( NULL );
		I$SchemaName$GelSequenceEditObj* editMe = dynamic_cast&lt;I$SchemaName$GelSequenceEditObj*&gt;( beginEdit() );
		I$SchemaName$GelCallObj* lastObj = getOptionalLookupLastInst();
		editNewCall-&gt;setOptionalLookupPrevInst( lastObj );
		newCallObj = dynamic_cast&lt;I$SchemaName$GelCallObj*&gt;( editNewCall-&gt;create() );
		if( lastObj != NULL ) {
			I$SchemaName$GelCallEditObj* editLast = dynamic_cast&lt;I$SchemaName$GelCallEditObj*&gt;( lastObj-&gt;beginEdit() );
			editLast-&gt;setOptionalLookupNextInst( newCallObj );
			editLast-&gt;update();
			editLast = NULL;
		}
		else {
			editMe-&gt;setOptionalLookupFirstInst( newCallObj );
		}
		editMe-&gt;setOptionalLookupLastInst( newCallObj );
		editMe-&gt;update();
		editMe = NULL;
	}

	std::string $SchemaName$GelSequenceObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		std::string emptyString;
		std::string expansion;
		std::string subExpansion;

		// Preload the instructions to avoid a read storm
		int64_t tentid = getRequiredTenantId();
		int64_t cacheid = getRequiredGelCacheId();
		int64_t instid = getRequiredGelInstId();
		std::vector&lt;ICFGenKbGelCallObj*&gt; calls = genContext-&gt;getGenEngine()-&gt;getGelCallTableObj()-&gt;readGelCallBySeqIdx( &amp;tentid,
			&amp;cacheid,
			&amp;instid );

		I$SchemaName$GelInstructionObj* nextCalled;
		I$SchemaName$GelCallObj* nextCall = getOptionalLookupFirstInst();
		while( nextCall != NULL ) {
			nextCalled = nextCall-&gt;getOptionalLookupCallInst();
			if( nextCalled != NULL ) {
				subExpansion = nextCalled-&gt;expand( genContext );
				if( genContext-&gt;isExpansionNull() ) {
					subExpansion = "$$" + nextCalled-&gt;getRequiredSourceText() + "$$";
					genContext-&gt;clearExpansionIsNull();
				}
				expansion.append( subExpansion );
			}
			nextCall = nextCall-&gt;getOptionalLookupNextInst();
		}

		return( expansion );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );
		virtual void addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;
		virtual void addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	void $SchemaName$GelSequenceEditObj::addCalledInstruction( I$SchemaName$GelCacheObj* gelCache, I$SchemaName$GelInstructionObj* calledInstruction ) {
		static const std::string S_ProcName( "addCalledInstruction" );
		static const std::string S_UsageMsg( "You are not allowed to add a called instruction while a sequence is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}

	std::string $SchemaName$GelSequenceEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelSwitch"
			TableClassCode="a91e"
			DbName="gelswitch"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				DataType="GelCacheIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="ValueExpansion"
				IsNullable="false"
				DataType="GenItemNameType" />
		<TableCol Name="NilExpansion"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="EmptyExpansion"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="DefaultExpansion"
				IsNullable="false"
				DataType="GenItemNameType" />
		<PrimaryIndex Name="GelSwitchIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelswitch_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<SuperClassRelation Name="SuperClass"
				DbName="gelswitch_super"
				Suffix="SuperClass"
				FromIndex="GelSwitchIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.*;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		final String S_ProcName = &quot;$SchemaName$GelSwitchObj.expand() &quot;;

		String valueExpansion = getRequiredValueExpansion();
		if( ( valueExpansion == null ) || ( valueExpansion.length() == 0 ) ) {
			throw new RuntimeException( S_ProcName + &quot;ValueExpansion was not properly set&quot; );
		}

		I$SchemaName$GenItemObj valueItem = genContext.getGenEngine().findContextItem(genContext, valueExpansion );
		if( valueItem == null ) {
			throw new RuntimeException( S_ProcName + &quot;Could not resolve Value expansion \&quot;&quot; + valueExpansion + &quot;\&quot;&quot; );
		}

		String valueStrValue;
		if( valueItem instanceof MssCFGenFileObj ) {
			valueStrValue = ((MssCFGenFileObj)valueItem).expandBody( genContext );
		}
		else if( valueItem instanceof MssCFGenRuleObj ) {
			valueStrValue = ((MssCFGenRuleObj)valueItem).expandBody( genContext );
		}
		else if (valueItem instanceof MssCFGenTruncObj) {
			valueStrValue = ((MssCFGenTruncObj)valueItem).expandBody( genContext );
		}
		else if (valueItem instanceof MssCFGenBindObj) {
			valueStrValue = ((MssCFGenBindObj)valueItem).expandBody( genContext );
		}
		else if( valueItem instanceof MssCFGenReferenceObj ) {
			throw new RuntimeException(S_ProcName + &quot;Cannot expand reference &quot; + valueItem.getRequiredName() + &quot; directly&quot;);
		}
		else if( valueItem instanceof MssCFGenIteratorObj ) {
			valueStrValue = ((MssCFGenIteratorObj)valueItem).expandBody( genContext );
		}
		else {
			throw new RuntimeException( S_ProcName +  &quot;Unsupported generation item class&quot; );
		}

		//	If null was returned, invoke either the nil or default macro
		//	and return the result

		String retval;
		if( valueStrValue == null ) {

			String effectiveExpansion = getOptionalNilExpansion();
			if( ( effectiveExpansion == null ) || ( effectiveExpansion.length() == 0 ) ) {
				effectiveExpansion = getRequiredDefaultExpansion();
				if( ( effectiveExpansion == null ) || ( effectiveExpansion.length() == 0 ) ) {
					throw new RuntimeException( S_ProcName + &quot;Neither NilExpansion nor DefaultExpansion were compiled properly&quot; );
				}
			}

			I$SchemaName$GenItemObj genItem = genContext.getGenEngine().findContextItem(genContext, effectiveExpansion );
			if( genItem == null ) {
				throw new RuntimeException( S_ProcName + &quot;Could not resolve expansion \&quot;&quot; + effectiveExpansion + &quot;\&quot;&quot; );
			}

			if( genItem instanceof MssCFGenFileObj ) {
				retval = ((MssCFGenFileObj)genItem).expandBody( genContext );
			}
			else if( genItem instanceof MssCFGenRuleObj ) {
				retval = ((MssCFGenRuleObj)genItem).expandBody( genContext );
			}
			else if (genItem instanceof MssCFGenTruncObj) {
				retval = ((MssCFGenTruncObj)genItem).expandBody( genContext );
			}
			else if (genItem instanceof MssCFGenBindObj) {
				retval = ((MssCFGenBindObj)genItem).expandBody( genContext );
			}
			else if( genItem instanceof MssCFGenReferenceObj ) {
				throw new RuntimeException(S_ProcName + &quot;Cannot expand reference &quot; + genItem.getRequiredName() + &quot; directly&quot;);
			}
			else if( genItem instanceof MssCFGenIteratorObj ) {
				retval = ((MssCFGenIteratorObj)genItem).expandBody( genContext );
			}
			else {
				throw new RuntimeException( S_ProcName +  &quot;Unsupported generation item class&quot; );
			}
		}
		else if( valueStrValue.length() == 0 ) {

			String effectiveExpansion = getOptionalEmptyExpansion();
			if( ( effectiveExpansion == null ) || ( effectiveExpansion.length() == 0 ) ) {
				effectiveExpansion = getRequiredDefaultExpansion();
				if( ( effectiveExpansion == null ) || ( effectiveExpansion.length() == 0 ) ) {
					throw new RuntimeException( S_ProcName + &quot;Neither EmptyExpansion nor DefaultExpansion were compiled properly&quot; );
				}
			}

			I$SchemaName$GenItemObj genItem = genContext.getGenEngine().findContextItem(genContext, effectiveExpansion );
			if( genItem == null ) {
				throw new RuntimeException( S_ProcName + &quot;Could not resolve expansion \&quot;&quot; + effectiveExpansion + &quot;\&quot;&quot; );
			}

			if( genItem instanceof MssCFGenFileObj ) {
				retval = ((MssCFGenFileObj)genItem).expandBody( genContext );
			}
			else if( genItem instanceof MssCFGenRuleObj ) {
				retval = ((MssCFGenRuleObj)genItem).expandBody( genContext );
			}
			else if (genItem instanceof MssCFGenTruncObj) {
				retval = ((MssCFGenTruncObj)genItem).expandBody( genContext );
			}
			else if (genItem instanceof MssCFGenBindObj) {
				retval = ((MssCFGenBindObj)genItem).expandBody( genContext );
			}
			else if( genItem instanceof MssCFGenReferenceObj ) {
				throw new RuntimeException(S_ProcName + &quot;Cannot expand reference &quot; + genItem.getRequiredName() + &quot; directly&quot;);
			}
			else if( genItem instanceof MssCFGenIteratorObj ) {
				retval = ((MssCFGenIteratorObj)genItem).expandBody( genContext );
			}
			else {
				throw new RuntimeException( S_ProcName +  &quot;Unsupported generation item class&quot; );
			}
		}
		else {
			String effectiveExpansion;
			I$SchemaName$GelSwitchLimbObj switchLimb = genContext.getGenEngine().getGelSwitchLimbTableObj().readGelSwitchLimbByPIdx( getRequiredTenantId(), getRequiredGelCacheId(), getRequiredGelInstId(), valueStrValue );
			if( switchLimb != null ) {
				effectiveExpansion = switchLimb.getRequiredLimbExpansion();
				if( ( effectiveExpansion == null ) || ( effectiveExpansion.length() == 0 ) ) {
					throw new RuntimeException( S_ProcName + &quot;Switch limb for &quot; + valueStrValue + &quot; nas a null or empty LimbExpansion&quot; );
				}
			}
			else {
				effectiveExpansion = getRequiredDefaultExpansion();
				if( ( effectiveExpansion == null ) || ( effectiveExpansion.length() == 0 ) ) {
					throw new RuntimeException( S_ProcName + &quot;Switch nas a null or empty DefaultExpansion&quot; );
				}
			}

			I$SchemaName$GenItemObj genItem = genContext.getGenEngine().findContextItem(genContext, effectiveExpansion );
			if( genItem == null ) {
				throw new RuntimeException( S_ProcName + &quot;Could not resolve expansion \&quot;&quot; + effectiveExpansion + &quot;\&quot;&quot; );
			}

			if( genItem instanceof MssCFGenFileObj ) {
				retval = ((MssCFGenFileObj)genItem).expandBody( genContext );
			}
			else if( genItem instanceof MssCFGenRuleObj ) {
				retval = ((MssCFGenRuleObj)genItem).expandBody( genContext );
			}
			else if (genItem instanceof MssCFGenTruncObj) {
				retval = ((MssCFGenTruncObj)genItem).expandBody( genContext );
			}
			else if (genItem instanceof MssCFGenBindObj) {
				retval = ((MssCFGenBindObj)genItem).expandBody( genContext );
			}
			else if( genItem instanceof MssCFGenReferenceObj ) {
				throw new RuntimeException(S_ProcName + &quot;Cannot expand reference &quot; + genItem.getRequiredName() + &quot; directly&quot;);
			}
			else if( genItem instanceof MssCFGenIteratorObj ) {
				retval = ((MssCFGenIteratorObj)genItem).expandBody( genContext );
			}
			else {
				throw new RuntimeException( S_ProcName +  &quot;Unsupported generation item class&quot; );
			}
		}

		if( retval == null ) {
			retval = &quot;$$&quot; + getRequiredSourceText() + &quot;$$&quot;;
		}

		return( retval );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	std::string $SchemaName$GelSwitchObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );
		static const std::string S_ValueExpansion( "ValueExpansion" );
		static const std::string S_CouldNotResolveValueExpansion( "Could not resolve value expansion \"" );
		static const std::string S_CouldNotResolveEffectiveExpansion( "Could not resolve effective expansion \"" );
		static const std::string S_DQuote( "\"" );
		static const std::string S_ExpectedValueItemClass( "Expected value item to be one of MssCFGenFileObj, MssCFGenRuleObj, MssCFGenTruncObj, MssCFGenBindObj, MssCFGenReferenceObj, or MssCFGenIterator, not " );
		static const std::string S_ExpectedGenItemClass( "Expected generation item to be one of MssCFGenFileObj, MssCFGenRuleObj, MssCFGenTruncObj, MssCFGenBindObj, MssCFGenReferenceObj, or MssCFGenIterator, not " );
		static const std::string S_NeitherEmptyNorDefaultCompiledProperly( "Neither EmptyExpansion nor DefaultExpansion were compiled properly" );
		static const std::string S_SwitchLimbFor( "Switch limb for " );
		static const std::string S_HasAnEmptyLimbExpansion( " has an empty LimbExpansion" );
		static const std::string S_HasAnEmptyDefaultExpansion( " has an empty DefaultExpansion" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		std::string valueExpansion = getRequiredValueExpansion();
		if( valueExpansion.length() &lt;= 0 ) {
			throw cflib::CFLibEmptyArgumentException( CLASS_NAME, S_ProcName, S_ValueExpansion );
		}

		I$SchemaName$GenItemObj* valueItem = genContext-&gt;getGenEngine()-&gt;findContextItem( genContext, valueExpansion );
		if( valueItem == NULL ) {
			std::string S_Msg( S_CouldNotResolveValueExpansion + valueExpansion + S_DQuote );
			throw cflib::CFLibRuntimeException( CLASS_NAME, S_ProcName, S_Msg );
		}

		// Evaluate the value item's expansion

		std::string valueStrValue;

		MssCFGenFileObj* genFileItem = dynamic_cast&lt;MssCFGenFileObj*&gt;( valueItem );
		if( genFileItem != NULL ) {
			valueStrValue = genFileItem-&gt;expandBody( genContext );
		}
		else {
			MssCFGenRuleObj* genRuleItem = dynamic_cast&lt;MssCFGenRuleObj*&gt;( valueItem );
			if( genRuleItem != NULL ) {
				valueStrValue = genRuleItem-&gt;expandBody( genContext );
			}
			else {
				MssCFGenTruncObj* genTruncItem = dynamic_cast&lt;MssCFGenTruncObj*&gt;( valueItem );
				if( genTruncItem != NULL ) {
					valueStrValue = genTruncItem-&gt;expandBody( genContext );
				}
				else {
					MssCFGenBindObj* genBindItem = dynamic_cast&lt;MssCFGenBindObj*&gt;( valueItem );
					if( genBindItem != NULL ) {
						valueStrValue = genBindItem-&gt;expandBody( genContext );
					}
					else {
						MssCFGenReferenceObj* genReferenceItem = dynamic_cast&lt;MssCFGenReferenceObj*&gt;( valueItem );
						if( genReferenceItem != NULL ) {
							valueStrValue = genReferenceItem-&gt;expandBody( genContext );
						}
						else {
							MssCFGenIteratorObj* genIteratorItem = dynamic_cast&lt;MssCFGenIteratorObj*&gt;( valueItem );
							if( genIteratorItem != NULL ) {
								valueStrValue = genIteratorItem-&gt;expandBody( genContext );
							}
							else {
								std::string S_Msg( S_ExpectedValueItemClass + valueItem-&gt;getClassName() );
								throw cflib::CFLibUnsupportedClassException( CLASS_NAME, S_ProcName, S_Msg );
							}
						}
					}
				}
			}
		}

		std::string expansion;

		// IF null was evaluated 
		// THEN

		if( genContext-&gt;isExpansionNull() ) {

			// Determine the effective expansion

			const std::string* effectiveExpansion = getOptionalNilExpansionReference();
			if( ( effectiveExpansion == NULL ) || ( effectiveExpansion-&gt;length() == 0 ) ) {
				effectiveExpansion = &amp;getRequiredDefaultExpansion();
				if( ( effectiveExpansion == NULL ) || ( effectiveExpansion-&gt;length() == 0 ) ) {
					throw cflib::CFLibRuntimeException( CLASS_NAME, S_ProcName, S_NeitherEmptyNorDefaultCompiledProperly  );
				}
			}

			// Find the generation item corresponding to the effective expansion

			I$SchemaName$GenItemObj* genItem = genContext-&gt;getGenEngine()-&gt;findContextItem( genContext, *effectiveExpansion );
			if( genItem == NULL ) {
				std::string S_Msg( S_CouldNotResolveEffectiveExpansion + *effectiveExpansion + S_DQuote );
				throw cflib::CFLibRuntimeException( CLASS_NAME, S_ProcName, S_Msg );
			}

			// Expand the generation item

			MssCFGenFileObj* genFileItem = dynamic_cast&lt;MssCFGenFileObj*&gt;( genItem );
			if( genFileItem != NULL ) {
				expansion = genFileItem-&gt;expandBody( genContext );
			}
			else {
				MssCFGenRuleObj* genRuleItem = dynamic_cast&lt;MssCFGenRuleObj*&gt;( genItem );
				if( genRuleItem != NULL ) {
					expansion = genRuleItem-&gt;expandBody( genContext );
				}
				else {
					MssCFGenTruncObj* genTruncItem = dynamic_cast&lt;MssCFGenTruncObj*&gt;( genItem );
					if( genTruncItem != NULL ) {
						expansion = genTruncItem-&gt;expandBody( genContext );
					}
					else {
						MssCFGenBindObj* genBindItem = dynamic_cast&lt;MssCFGenBindObj*&gt;( genItem );
						if( genBindItem != NULL ) {
							expansion = genBindItem-&gt;expandBody( genContext );
						}
						else {
							MssCFGenReferenceObj* genReferenceItem = dynamic_cast&lt;MssCFGenReferenceObj*&gt;( genItem );
							if( genReferenceItem != NULL ) {
								expansion = genReferenceItem-&gt;expandBody( genContext );
							}
							else {
								MssCFGenIteratorObj* genIteratorItem = dynamic_cast&lt;MssCFGenIteratorObj*&gt;( genItem );
								if( genIteratorItem != NULL ) {
									expansion = genIteratorItem-&gt;expandBody( genContext );
								}
								else {
									std::string S_Msg( S_ExpectedGenItemClass + genItem-&gt;getClassName() );
									throw cflib::CFLibUnsupportedClassException( CLASS_NAME, S_ProcName, S_Msg );
								}
							}
						}
					}
				}
			}

		// ELSE IF value string value is empty
		// THEN

		}
		else if( valueStrValue.length() == 0 ) {

			// Determine the effective expansion

			const std::string* effectiveExpansion = getOptionalEmptyExpansionReference();
			if( ( effectiveExpansion == NULL ) || ( effectiveExpansion-&gt;length() == 0 ) ) {
				effectiveExpansion = &amp;getRequiredDefaultExpansion();
				if( ( effectiveExpansion == NULL ) || ( effectiveExpansion-&gt;length() == 0 ) ) {
					throw cflib::CFLibRuntimeException( CLASS_NAME, S_ProcName, S_NeitherEmptyNorDefaultCompiledProperly  );
				}
			}

			// Find the generation item corresponding to the effective expansion

			I$SchemaName$GenItemObj* genItem = genContext-&gt;getGenEngine()-&gt;findContextItem( genContext, *effectiveExpansion );
			if( genItem == NULL ) {
				std::string S_Msg( S_CouldNotResolveEffectiveExpansion + *effectiveExpansion + S_DQuote );
				throw cflib::CFLibRuntimeException( CLASS_NAME, S_ProcName, S_Msg );
			}

			// Expand the generation item

			MssCFGenFileObj* genFileItem = dynamic_cast&lt;MssCFGenFileObj*&gt;( genItem );
			if( genFileItem != NULL ) {
				expansion = genFileItem-&gt;expandBody( genContext );
			}
			else {
				MssCFGenRuleObj* genRuleItem = dynamic_cast&lt;MssCFGenRuleObj*&gt;( genItem );
				if( genRuleItem != NULL ) {
					expansion = genRuleItem-&gt;expandBody( genContext );
				}
				else {
					MssCFGenTruncObj* genTruncItem = dynamic_cast&lt;MssCFGenTruncObj*&gt;( genItem );
					if( genTruncItem != NULL ) {
						expansion = genTruncItem-&gt;expandBody( genContext );
					}
					else {
						MssCFGenBindObj* genBindItem = dynamic_cast&lt;MssCFGenBindObj*&gt;( genItem );
						if( genBindItem != NULL ) {
							expansion = genBindItem-&gt;expandBody( genContext );
						}
						else {
							MssCFGenReferenceObj* genReferenceItem = dynamic_cast&lt;MssCFGenReferenceObj*&gt;( genItem );
							if( genReferenceItem != NULL ) {
								expansion = genReferenceItem-&gt;expandBody( genContext );
							}
							else {
								MssCFGenIteratorObj* genIteratorItem = dynamic_cast&lt;MssCFGenIteratorObj*&gt;( genItem );
								if( genIteratorItem != NULL ) {
									expansion = genIteratorItem-&gt;expandBody( genContext );
								}
								else {
									std::string S_Msg( S_ExpectedGenItemClass + genItem-&gt;getClassName() );
									throw cflib::CFLibUnsupportedClassException( CLASS_NAME, S_ProcName, S_Msg );
								}
							}
						}
					}
				}
			}
		}
		else {

		// ELSE

			std::string effectiveExpansion;

			// Determine the effective expansion

			I$SchemaName$GelSwitchLimbObj* switchLimb = genContext-&gt;getGenEngine()-&gt;getGelSwitchLimbTableObj()-&gt;readGelSwitchLimbByPIdx( getRequiredTenantId(),
				getRequiredGelCacheId(),
				getRequiredGelInstId(),
				valueStrValue );
			if( switchLimb != NULL ) {
				effectiveExpansion = switchLimb-&gt;getRequiredLimbExpansion();
				if( effectiveExpansion.length() &lt;= 0 ) {
					std::string S_Msg( S_SwitchLimbFor + valueStrValue + S_HasAnEmptyLimbExpansion );
					throw cflib::CFLibEmptyArgumentException( CLASS_NAME, S_ProcName, S_Msg );
				}
			}
			else {
				effectiveExpansion = getRequiredDefaultExpansion();
				if( effectiveExpansion.length() &lt;= 0 ) {
					std::string S_Msg( S_SwitchLimbFor + valueStrValue + S_HasAnEmptyDefaultExpansion );
					throw cflib::CFLibEmptyArgumentException( CLASS_NAME, S_ProcName, S_Msg );
				}
			}

			// Find the generation item corresponding to the effective expansion

			I$SchemaName$GenItemObj* genItem = genContext-&gt;getGenEngine()-&gt;findContextItem(genContext, effectiveExpansion );
			if( genItem == NULL ) {
				std::string S_Msg( S_CouldNotResolveEffectiveExpansion + effectiveExpansion + S_DQuote );
				throw cflib::CFLibRuntimeException( CLASS_NAME, S_ProcName, S_Msg );
			}

			// Expand the generation item

			MssCFGenFileObj* genFileItem = dynamic_cast&lt;MssCFGenFileObj*&gt;( genItem );
			if( genFileItem != NULL ) {
				expansion = genFileItem-&gt;expandBody( genContext );
			}
			else {
				MssCFGenRuleObj* genRuleItem = dynamic_cast&lt;MssCFGenRuleObj*&gt;( genItem );
				if( genRuleItem != NULL ) {
					expansion = genRuleItem-&gt;expandBody( genContext );
				}
				else {
					MssCFGenTruncObj* genTruncItem = dynamic_cast&lt;MssCFGenTruncObj*&gt;( genItem );
					if( genTruncItem != NULL ) {
						expansion = genTruncItem-&gt;expandBody( genContext );
					}
					else {
						MssCFGenBindObj* genBindItem = dynamic_cast&lt;MssCFGenBindObj*&gt;( genItem );
						if( genBindItem != NULL ) {
							expansion = genBindItem-&gt;expandBody( genContext );
						}
						else {
							MssCFGenReferenceObj* genReferenceItem = dynamic_cast&lt;MssCFGenReferenceObj*&gt;( genItem );
							if( genReferenceItem != NULL ) {
								expansion = genReferenceItem-&gt;expandBody( genContext );
							}
							else {
								MssCFGenIteratorObj* genIteratorItem = dynamic_cast&lt;MssCFGenIteratorObj*&gt;( genItem );
								if( genIteratorItem != NULL ) {
									expansion = genIteratorItem-&gt;expandBody( genContext );
								}
								else {
									std::string S_Msg( S_ExpectedGenItemClass + genItem-&gt;getClassName() );
									throw cflib::CFLibUnsupportedClassException( CLASS_NAME, S_ProcName, S_Msg );
								}
							}
						}
					}
				}
			}
		}

		return( expansion );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelSwitchEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelSwitchLimb"
			TableClassCode="a91f"
			DbName="gellimb"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Generation GEL Cache Id"
				IsNullable="false"
				DataType="GelCacheIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="LimbName"
				IsNullable="false"
				DataType="GenItemNameType" />
		<TableCol Name="LimbExpansion"
				IsNullable="false"
				DataType="GenItemNameType" />
		<PrimaryIndex Name="GelSwitchLimbIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gellimb_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
			<IndexCol Name="LimbName" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GelSwitchLimbTenantIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gellimb_xtenant"
				Suffix="TenantIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
		</Index>
		<Index Name="GelSwitchLimbSwitchIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gellimb_xswitch"
				Suffix="SwitchIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="GenItem"
			TableClassCode="a920"
			DbName="kbgenitem"
			Label="Generation Item"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="CartridgeId"
				Label="Cartridge Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="ItemId"
				Label="Item Id"
				IsNullable="false"
				GenerateId="true"
				DataType="GenItemIdGen" />
		<TableCol Name="RuleTypeId"
				Label="Rule Type Id"
				IsNullable="false"
				DataType="RuleTypeIdGen" />
		<TableCol Name="Name"
				DbName="safe_name"
				IsNullable="false"
				DataType="GenItemNameType" />
		<TableCol Name="ToolSetId"
				Label="Tool Set Id"
				IsNullable="false"
				DataType="ToolSetIdGen" />
		<TableCol Name="ScopeDefId"
				Label="Scope Definition Id"
				IsNullable="true"
				DataType="DefClassIdGen" />
		<TableCol Name="GenDefId"
				Label="Generation Definition Id"
				IsNullable="false"
				DataType="DefClassIdGen" />
		<TableCol Name="GelExecutableTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="GelExecutableGelCacheId"
				Label="GelCache Id"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="GelExecutableId"
				Label="GEL Executable Id"
				IsNullable="true"
				DbName="gelexec_id"
				DataType="GelInstructionIdGen" />
		<TableCol Name="ProbeTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="ProbeCartridgeId"
				IsNullable="true"
				DataType="RuleCartIdGen" />
		<TableCol Name="ProbeGenItemId"
				Label="Item Id"
				IsNullable="true"
				DataType="GenItemIdGen" />
		<PrimaryIndex Name="GenItemIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbgenitem_id"
				Suffix="ItemIdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="CartridgeId" IsAscending="true" />
			<IndexCol Name="ItemId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GenItemTenantIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbgenitem_tentx"
				Suffix="TenantIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
		</Index>
		<Index Name="GenItemCartIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbgenitem_cartx"
				Suffix="CartIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="CartridgeId" IsAscending="true" />
		</Index>
		<Index Name="GenItemRuleTypeIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbgenitem_rtyp"
				Suffix="RuleTypeIdx" >
			<IndexCol Name="RuleTypeId" IsAscending="true" />
		</Index>
		<Index Name="GenItemToolSetIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbgenitem_tset"
				Suffix="ToolSetIdx" >
			<IndexCol Name="ToolSetId" IsAscending="true" />
		</Index>
		<Index Name="GenItemScopeIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbgenitem_scpx"
				Suffix="ScopeIdx" >
			<IndexCol Name="ScopeDefId" IsAscending="true" />
		</Index>
		<Index Name="GenItemGenDefIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbgenitem_gdef"
				Suffix="GenDefIdx" >
			<IndexCol Name="GenDefId" IsAscending="true" />
		</Index>
		<Index Name="GenItemAlt"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbgenitem_alt"
				Suffix="AltIdx" >
			<IndexCol Name="Name" IsAscending="true" />
			<IndexCol Name="ToolSetId" IsAscending="true" />
			<IndexCol Name="ScopeDefId" IsAscending="true" />
			<IndexCol Name="GenDefId" IsAscending="true" />
		</Index>
		<Index Name="GenItemGelExecutableIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbgenitem_xgexec"
				Suffix="GelExecIdx" >
			<IndexCol Name="GelExecutableTenantId" IsAscending="true" />
			<IndexCol Name="GelExecutableGelCacheId" IsAscending="true" />
			<IndexCol Name="GelExecutableId" IsAscending="true" />
		</Index>
		<Index Name="GenItemProbeIdx"
				IsDbMapped="true"
				IsUnique="false"
				Suffix="ProbeIdx" >
			<IndexCol Name="ProbeTenantId" IsAscending="true" />
			<IndexCol Name="ProbeCartridgeId" IsAscending="true" />
			<IndexCol Name="ProbeGenItemId" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="GenIterator"
			TableClassCode="a921"
			DbName="kbgeniter"
			Label="Generation Iterator"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Insert"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="CartridgeId"
				Label="Cartridge Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="ItemId"
				Label="Item Id"
				IsNullable="false"
				DataType="GenItemIdGen" />
		<PrimaryIndex Name="GenIteratorIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbgeniter_id"
				Suffix="IdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="CartridgeId" IsAscending="true" />
			<IndexCol Name="ItemId" IsAscending="true" />
		</PrimaryIndex>
		<SuperClassRelation Name="SuperClass"
				DbName="kbgeniter_super"
				Suffix="SuperClass"
				FromIndex="GenIteratorIdIdx"
				ToIndex="GenItem.GenItemIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="CartridgeId" ToCol="CartridgeId" />
			<RelationCol Name="ItemId" ToCol="ItemId" />
		</SuperClassRelation>
	</Table>

	<Table Name="GenReference"
			TableClassCode="a922"
			DbName="kbgenref"
			Label="Generation Reference"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Insert"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="CartridgeId"
				Label="Cartridge Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="ItemId"
				Label="Item Id"
				IsNullable="false"
				DataType="GenItemIdGen" />
		<PrimaryIndex Name="GenReferenceIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbgenref_id"
				Suffix="IdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="CartridgeId" IsAscending="true" />
			<IndexCol Name="ItemId" IsAscending="true" />
		</PrimaryIndex>
		<SuperClassRelation Name="SuperClass"
				DbName="kbgenref_super"
				Suffix="SuperClass"
				FromIndex="GenReferenceIdIdx"
				ToIndex="GenItem.GenItemIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="CartridgeId" ToCol="CartridgeId" />
			<RelationCol Name="ItemId" ToCol="ItemId" />
		</SuperClassRelation>
	</Table>

	<Table Name="GenRule"
			TableClassCode="a923"
			DbName="kbgenrule"
			Label="Generation Rule"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="CartridgeId"
				Label="Cartridge Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="ItemId"
				Label="Item Id"
				IsNullable="false"
				DataType="GenItemIdGen" />
		<StringCol Name="DefinedNear"
				Label="Defined Near"
				IsNullable="false"
				MaxLen="2000"
				InitValue="internal" />
		<TextCol Name="Body"
				IsNullable="false"
				MaxLen="999999"
				InitValue="" />
		<TableCol Name="BodyTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="BodyGelCacheId"
				IsNullable="true"
				DataType="RuleCartIdGen" />
		<TableCol Name="BodyGelId"
				IsNullable="true"
				DbName="body_gelid"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GenRuleIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbgenrule_id"
				Suffix="IdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="CartridgeId" IsAscending="true" />
			<IndexCol Name="ItemId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="BodyIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="genrule_gelbodyidx"
				Suffix="BodyIdx" >
			<IndexCol Name="BodyTenantId" IsAscending="true" />
			<IndexCol Name="BodyGelCacheId" IsAscending="true" />
			<IndexCol Name="BodyGelId" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="srcbundle_super"
				Suffix="SuperClass"
				FromIndex="GenRuleIdIdx"
				ToIndex="GenItem.GenItemIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="CartridgeId" ToCol="CartridgeId" />
			<RelationCol Name="ItemId" ToCol="ItemId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGelCompiler;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public static I$SchemaName$GelExecutableObj getBodyBin( MssCFGelCompiler gelCompiler, I$SchemaName$GenRuleObj genRule ) {
		final String S_ProcName = &quot;$SchemaName$GenRuleObj.getBodyBin() &quot;;
		I$SchemaName$GelExecutableObj bin = genRule.getOptionalComponentsBodyGel();
		if( bin == null ) {
			String execName = genRule.getRequiredLookupToolSet().getRequiredName()
				+ "::" + genRule.getRequiredLookupRuleType().getRequiredName()
				+ "::" + (( genRule.getOptionalLookupScopeDef() == null ) ? "Object" : genRule.getOptionalLookupScopeDef().getRequiredName() )
				+ "::" + genRule.getRequiredLookupGenDef().getRequiredName()
				+ "::" + genRule.getRequiredName()
				+ "::Body";
			String source = genRule.getRequiredBody();
			bin = gelCompiler.compileExecutable( execName, source );
			if( bin == null ) {
				throw new RuntimeException( S_ProcName + &quot;Could not compile Body GEL executable from source \&quot;&quot; + source + &quot;\&quot;&quot; );
			}

			I$SchemaName$GenRuleEditObj editRule = genRule.getEditAsGenRule();
			if( editRule != null ) {
				editRule.setOptionalComponentsBodyGel( bin );
			}
			else {
				editRule = (I$SchemaName$GenRuleEditObj)genRule.beginEdit();
				editRule.setOptionalComponentsBodyGel( bin );
				editRule.update();
				editRule = null;
			}
		}
		return( bin );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		static I$SchemaName$GelExecutableObj* getBodyBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenRuleObj* genRule );</CPlusObjInterface>

		<HPlusObjInterface></HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	I$SchemaName$GelExecutableObj* $SchemaName$GenRuleObj::getBodyBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenRuleObj* genRule ) {
		static const std::string S_ProcName( "GenRule.getBodyBin" );
		static const std::string S_CouldNotCompileBodyGel( "Could not compile Body GEL executable from source \"" );
		static const std::string S_DQuote( "\" near " );
		static const std::string S_Dash( " - " );
		static const std::string S_ColonColon( "::" );
		static const std::string S_Object( "Object" );
		static const std::string S_ColonColonBody( "::Body" );
		I$SchemaName$GelExecutableObj* bin = genRule-&gt;getOptionalComponentsBodyGel();
		if( bin == NULL ) {
			std::string execName( genRule-&gt;getRequiredLookupToolSet()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genRule-&gt;getRequiredLookupRuleType()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( ( genRule-&gt;getOptionalLookupScopeDef() == NULL ) ? std::string( S_Object ) : genRule-&gt;getOptionalLookupScopeDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genRule-&gt;getRequiredLookupGenDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genRule-&gt;getRequiredName() );
			execName.append( S_ColonColonBody );
			std::string source = genRule-&gt;getRequiredBody();
			bin = gelCompiler-&gt;compileExecutable( execName, source );
			I$SchemaName$GenRuleEditObj* editRule = genRule-&gt;getGenRuleEdit();
			if( editRule != NULL ) {
				editRule-&gt;setOptionalComponentsBodyGel( bin );
			}
			else {
				editRule = dynamic_cast&lt;I$SchemaName$GenRuleEditObj*&gt;( genRule-&gt;beginEdit() );
				editRule-&gt;setOptionalComponentsBodyGel( bin );
				editRule-&gt;update();
				editRule = NULL;
			}
		}
		return( bin );
	}
</CPlusObjImplementation>
	</Table>

	<Table Name="GenTrunc"
			TableClassCode="a924"
			DbName="kbgentrunc"
			Label="Generation Truncation"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="CartridgeId"
				Label="Cartridge Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="ItemId"
				Label="Item Id"
				IsNullable="false"
				DataType="GenItemIdGen" />
		<Int32Col Name="TruncateAt"
				Label="Truncate At"
				IsNullable="false"
				MinValue="0"
				MaxValue="2147483647"
				InitValue="0" />
		<PrimaryIndex Name="GenTruncIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbgentrunc_id"
				Suffix="IdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="CartridgeId" IsAscending="true" />
			<IndexCol Name="ItemId" IsAscending="true" />
		</PrimaryIndex>
		<SuperClassRelation Name="SuperClass"
				DbName="kbgentrunc_super"
				Suffix="SuperClass"
				FromIndex="GenTruncIdIdx"
				ToIndex="GenRule.GenRuleIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="CartridgeId" ToCol="CartridgeId" />
			<RelationCol Name="ItemId" ToCol="ItemId" />
		</SuperClassRelation>
	</Table>

	<Table Name="RuleCart"
			TableClassCode="a925"
			DbName="kbrulecart"
			Label="Rule Cartridge"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LookupIndex="RuleCartName"
			LoaderBehaviour="Replace"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="Id"
				IsNullable="false"
				GenerateId="true"
				DataType="RuleCartIdGen" />
		<StringCol Name="Name"
				DbName="safe_name"
				IsNullable="false"
				MaxLen="127"
				InitValue="" />
		<StringCol Name="Descr"
				Label="Description"
				IsNullable="true"
				MaxLen="255"
				/>
		<StringCol Name="RevisionString"
				Label="Revision String"
				IsNullable="true"
				MaxLen="255"
				/>
		<PrimaryIndex Name="RuleCartIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbrulecart_idx"
				Suffix="IdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="Id" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="RuleCartTenant"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbrulecart_xtenant"
				Suffix="TenantIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
		</Index>
		<Index Name="RuleCartName"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbrulecart_uxname"
				Suffix="NameIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="Name" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="RuleType"
			TableClassCode="a926"
			DbName="kbruletype"
			Label="Rule Type"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LookupIndex="RuleTypeName"
			LoaderBehaviour="Insert"
			SecScope="None" >
		<TableCol Name="Id"
				IsNullable="false"
				GenerateId="true"
				DataType="RuleTypeIdGen" />
		<StringCol Name="Name"
				DbName="safe_name"
				IsNullable="false"
				MaxLen="32"
				InitValue="" />
		<PrimaryIndex Name="RuleTypeIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbruletype_xid"
				Suffix="IdIdx" >
			<IndexCol Name="Id" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="RuleTypeName"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbruletype_xname"
				Suffix="NameIdx" >
			<IndexCol Name="Name" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="Tool"
			TableClassCode="a927"
			DbName="kbtool"
			Label="Tool"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LookupIndex="ToolName"
			LoaderBehaviour="Insert"
			SecScope="None" >
		<TableCol Name="Id"
				IsNullable="false"
				GenerateId="true"
				DataType="ToolIdGen" />
		<StringCol Name="Name"
				DbName="safe_name"
				IsNullable="false"
				MaxLen="32"
				InitValue="" />
		<TableCol Name="ReplacesId"
				Label="Replaces Tool Id"
				IsNullable="true"
				DataType="ToolIdGen" />
		<BoolCol Name="IsSupported"
				Label="Is Supported"
				IsNullable="false"
				/>
		<PrimaryIndex Name="ToolIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbtool_xid"
				Suffix="IdIdx" >
			<IndexCol Name="Id" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="ToolName"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbtool_xname"
				Suffix="NameIdx" >
			<IndexCol Name="Name" IsAscending="true" />
		</Index>
		<Index Name="ToolReplacesIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbtool_xreplaces"
				Suffix="ReplacesIdx" >
			<IndexCol Name="ReplacesId" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="ToolSet"
			TableClassCode="a928"
			DbName="kbtoolset"
			Label="Tool Set"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LookupIndex="ToolSetName"
			LoaderBehaviour="Insert"
			SecScope="None" >
		<TableCol Name="Id"
				IsNullable="false"
				GenerateId="true"
				DataType="ToolSetIdGen" />
		<StringCol Name="Name"
				DbName="safe_name"
				IsNullable="false"
				MaxLen="511"
				InitValue="" />
		<StringCol Name="Descr"
				Label="Description"
				IsNullable="true"
				MaxLen="255"
				/>
		<StringCol Name="RevisionString"
				Label="Revision String"
				IsNullable="true"
				MaxLen="255"
				/>
		<BoolCol Name="IsSupported"
				Label="Is Supported"
				IsNullable="false"
				InitValue="true"
				/>
		<BoolCol Name="Generate"
				IsNullable="false"
				InitValue="true"
				/>
		<TableCol Name="ToolId0"
				Label="Tool Id 0"
				IsNullable="false"
				DataType="ToolIdGen" />
		<TableCol Name="ToolId1"
				Label="Tool Id 1"
				IsNullable="true"
				DataType="ToolIdGen" />
		<TableCol Name="ToolId2"
				Label="Tool Id 2"
				IsNullable="true"
				DataType="ToolIdGen" />
		<TableCol Name="ToolId3"
				Label="Tool Id 3"
				IsNullable="true"
				DataType="ToolIdGen" />
		<TableCol Name="ToolId4"
				Label="Tool Id 4"
				IsNullable="true"
				DataType="ToolIdGen" />
		<TableCol Name="ToolId5"
				Label="Tool Id 5"
				IsNullable="true"
				DataType="ToolIdGen" />
		<TableCol Name="ToolId6"
				Label="Tool Id 6"
				IsNullable="true"
				DataType="ToolIdGen" />
		<TableCol Name="ToolId7"
				Label="Tool Id 7"
				IsNullable="true"
				DataType="ToolIdGen" />
		<PrimaryIndex Name="ToolSetIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbtoolset_xid"
				Suffix="IdIdx" >
			<IndexCol Name="Id" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="ToolSetName"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbtoolset_xname"
				Suffix="NameIdx" >
			<IndexCol Name="Name" IsAscending="true" />
		</Index>
		<Index Name="ToolSetTool0Idx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbtoolset_xt0"
				Suffix="Tool0Idx" >
			<IndexCol Name="ToolId0" IsAscending="true" />
		</Index>
		<Index Name="ToolSetTool1Idx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbtoolset_xt1"
				Suffix="Tool1Idx" >
			<IndexCol Name="ToolId1" IsAscending="true" />
		</Index>
		<Index Name="ToolSetTool2Idx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbtoolset_xt2"
				Suffix="Tool2Idx" >
			<IndexCol Name="ToolId2" IsAscending="true" />
		</Index>
		<Index Name="ToolSetTool3Idx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbtoolset_xt3"
				Suffix="Tool3Idx" >
			<IndexCol Name="ToolId3" IsAscending="true" />
		</Index>
		<Index Name="ToolSetTool4Idx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbtoolset_xt4"
				Suffix="Tool4Idx" >
			<IndexCol Name="ToolId4" IsAscending="true" />
		</Index>
		<Index Name="ToolSetTool5Idx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbtoolset_xt5"
				Suffix="Tool5Idx" >
			<IndexCol Name="ToolId5" IsAscending="true" />
		</Index>
		<Index Name="ToolSetTool6Idx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbtoolset_xt6"
				Suffix="Tool6Idx" >
			<IndexCol Name="ToolId6" IsAscending="true" />
		</Index>
		<Index Name="ToolSetTool7Idx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="kbtoolset_xt7"
				Suffix="Tool7Idx" >
			<IndexCol Name="ToolId7" IsAscending="true" />
		</Index>
	</Table>

	<Table Name="GelBoilerplate"
			TableClassCode="a929"
			DbName="gelboiler"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="GelCache Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GelBoilerplateIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelboiler_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<SuperClassRelation Name="SuperClass"
				DbName="gelboiler_super"
				Suffix="SuperClass"
				FromIndex="GelBoilerplateIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		String expansion = getRequiredSourceText();
		return( expansion );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	std::string $SchemaName$GelBoilerplateObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		std::string expansion( getRequiredSourceText() );
		genContext-&gt;clearExpansionIsNull();
		return( expansion );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelBoilerplateEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelError"
			TableClassCode="a92a"
			DbName="gelerror"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="GelCache Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GelErrorIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelerror_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<SuperClassRelation Name="SuperClass"
				DbName="gelerror_super"
				Suffix="SuperClass"
				FromIndex="GelErrorIdIdx"
				ToIndex="GelBoilerplate.GelBoilerplateIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		String expansion = getRequiredSourceText();
		return( expansion );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	std::string $SchemaName$GelErrorObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		std::string expansion( getRequiredSourceText() );
		genContext-&gt;clearExpansionIsNull();
		return( expansion );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelErrorEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelBuiltin"
			TableClassCode="a92b"
			DbName="gelbuiltin"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="GelCache Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GelBuiltinIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelbuiltin_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<SuperClassRelation Name="SuperClass"
				DbName="gelbuiltin_super"
				Suffix="SuperClass"
				FromIndex="GelBuiltinIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		throw new RuntimeException( &quot;$SchemaName$GelBuiltinObj.expand() must be specialized by the builtin implementation&quot; );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	std::string $SchemaName$GelBuiltinObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );
		static const std::string S_Msg( "Method must be overridden by BuiltIn specialization" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		throw cflib::CFLibMustOverrideException( CLASS_NAME, S_ProcName, S_Msg );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelBuiltinEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelConstrain"
			TableClassCode="a92c"
			DbName="gelconstrain"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Source Generation Item GelCache Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<Int64Col Name="HardConstraint"
				IsNullable="true"
				/>
		<TableCol Name="ConstrainingName"
				IsNullable="true"
				DataType="GenItemNameType" />
		<TableCol Name="RemainderTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="RemainderGelCacheId"
				Label="Source Generation Item GelCache Id"
				IsNullable="false"
				GenerateId="true"
				DataType="RuleCartIdGen" />
		<TableCol Name="RemainderInstId"
				Label="Remainder Instruction Id"
				IsNullable="true"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GelConstrainIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelconstrain_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GelConstrainRemainderInstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelconstrain_xremainder"
				Suffix="RemainderIdx" >
			<IndexCol Name="RemainderTenantId" IsAscending="true" />
			<IndexCol Name="RemainderGelCacheId" IsAscending="true" />
			<IndexCol Name="RemainderInstId" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="gelconstrain_super"
				Suffix="SuperClass"
				FromIndex="GelConstrainIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		throw new RuntimeException( &quot;$SchemaName$GelConstrainObj.expand() Implemention must be overriden by constraint specialization&quot;);
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {
	std::string $SchemaName$GelConstrainObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );
		static const std::string S_Msg( "Implementation must be overridden by Constrain specialization" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		throw cflib::CFLibMustOverrideException( CLASS_NAME, S_ProcName, S_Msg );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelConstrainEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelCounter"
			TableClassCode="a92d"
			DbName="gelcounter"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Source Generation Item GelCache Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="CounterName"
				IsNullable="false"
				DataType="GenItemNameType" />
		<PrimaryIndex Name="GelCounterIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelcounter_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<SuperClassRelation Name="SuperClass"
				DbName="gelcounter_super"
				Suffix="SuperClass"
				FromIndex="GelCounterIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		throw new RuntimeException( &quot;$SchemaName$GelCounterObj.expand() Implemention must be overriden by counter specialization&quot;);
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	std::string $SchemaName$GelCounterObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_Msg( "Implementation must be overridden by Counter specialization" );
		throw cflib::CFLibMustOverrideException( CLASS_NAME, S_ProcName, S_Msg );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelCounterEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelExecutable"
			TableClassCode="a92e"
			DbName="gelexec"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Source Generation Item GelCache Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="GenItemId"
				Label="Source Generation Item Id"
				IsNullable="false"
				DataType="GenItemIdGen" />
		<PrimaryIndex Name="GelExecutableIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelexec_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GelExecutableGelCacheIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelexec_xgelcache"
				Suffix="GenItemIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="gelexec_super"
				Suffix="SuperClass"
				FromIndex="GelExecutableIdIdx"
				ToIndex="GelSequence.GelSequenceIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjInterface>
	public void addCalledInstruction( I$SchemaName$GelCacheObj gelCache, I$SchemaName$GelInstructionObj calledInstruction );
	public String expand( MssCFGenContext genContext );</CafeObjInterface>

		<CafeObjImplementation>
	public void addCalledInstruction( I$SchemaName$GelCacheObj gelCache, I$SchemaName$GelInstructionObj calledInstruction ) {
		I$SchemaName$GelCallObj newCallObj = schema.getGelCallTableObj().newInstance();
		I$SchemaName$GelCallEditObj editNewCall = (I$SchemaName$GelCallEditObj)( newCallObj.beginEdit() );
		editNewCall.setRequiredOwnerTenant( getRequiredOwnerTenant() );
		editNewCall.setRequiredContainerGelCache( getRequiredContainerGelCache() );
		editNewCall.setOptionalParentSeqInst( this );
		editNewCall.setOptionalLookupCallInst( calledInstruction );
		editNewCall.setOptionalLookupNextInst( null );
		I$SchemaName$GelCallObj lastObj = getOptionalLookupLastInst();
		editNewCall.setOptionalLookupPrevInst( lastObj );
		newCallObj = (I$SchemaName$GelCallObj)( editNewCall.create() );
		editNewCall = null;
		I$SchemaName$GelSequenceEditObj editMe = (I$SchemaName$GelSequenceEditObj)beginEdit();
		if( lastObj != null ) {
			I$SchemaName$GelCallEditObj editLast = (I$SchemaName$GelCallEditObj)( lastObj.beginEdit() );
			editLast.setOptionalLookupNextInst( newCallObj );
			editLast.update();
			editLast = null;
		}
		else {
			editMe.setOptionalLookupFirstInst( newCallObj );
		}
		editMe.setOptionalLookupLastInst( newCallObj );
		editMe.update();
		editMe = null;
	}

	public String expand( MssCFGenContext genContext ) {
		final String S_ProcName = "expand";
		final String S_GenContext = "genContext";

		if( genContext == null ) {
			throw new CFLibNullArgumentException( getClass(), S_ProcName, 1, S_GenContext );
		}

		StringBuffer expansion = new StringBuffer();
		String subExpansion;

		// Preload the instructions to avoid a read storm
		genContext.getGenEngine().getGelCallTableObj().readGelCallBySeqIdx( getRequiredTenantId(), getRequiredGelCacheId(), getRequiredGelInstId() );

		I$SchemaName$GelInstructionObj nextCalled;
		I$SchemaName$GelCallObj nextCall = getOptionalLookupFirstInst();
		while( nextCall != null ) {
			nextCalled = nextCall.getOptionalLookupCallInst();
			if( nextCalled != null ) {
				subExpansion = nextCalled.expand( genContext );
				if( subExpansion == null ) {
					subExpansion = "$$" + nextCalled.getRequiredSourceText() + "$$";
				}
				expansion.append( subExpansion );
			}
			nextCall = nextCall.getOptionalLookupNextInst();
		}

		return( expansion.toString() );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {
	std::string $SchemaName$GelExecutableObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		// Preload the instructions to avoid a read storm
		int64_t tentid = getRequiredTenantId();
		int64_t cacheid = getRequiredGelCacheId();
		int64_t instid = getRequiredGelInstId();
		std::vector&lt;ICFGenKbGelCallObj*&gt; calls = genContext-&gt;getGenEngine()-&gt;getGelCallTableObj()-&gt;readGelCallBySeqIdx( &amp;tentid,
			&amp;cacheid,
			&amp;instid );

		std::string expansion;
		std::string subExpansion;

		I$SchemaName$GelCallObj* nextCall = getOptionalLookupFirstInst();
		while( nextCall != NULL ) {
			I$SchemaName$GelInstructionObj* callInst = nextCall-&gt;getOptionalLookupCallInst();
			if( callInst != NULL ) {
				subExpansion = callInst-&gt;expand( genContext );
				if( genContext-&gt;isExpansionNull() ) {
					expansion.append( "$$" + callInst-&gt;getRequiredSourceText() + "$$" );
				}
				else  {
					expansion.append( subExpansion );
				}
				genContext-&gt;clearExpansionIsNull();
			}
			nextCall = nextCall-&gt;getOptionalLookupNextInst();
		}

		genContext-&gt;clearExpansionIsNull();

		return( expansion );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>
namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelExecutableEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelExpansion"
			TableClassCode="a92f"
			DbName="gelexpansion"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Source Generation Item GelCache Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="MacroName"
				IsNullable="false"
				DataType="GenItemNameType" />
		<PrimaryIndex Name="GelExpansionIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelexpansion_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<SuperClassRelation Name="SuperClass"
				DbName="gelexpansion_super"
				Suffix="SuperClass"
				FromIndex="GelExpansionIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.*;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		String retval;
		final String S_ProcName = &quot;$SchemaName$GelExpansion.expand() &quot;;
		I$SchemaName$GenItemObj genItem = genContext.getGenEngine().findContextItem(genContext, getRequiredMacroName() );
		if( genItem != null ) {
			if( genItem instanceof MssCFGenFileObj ) {
				retval = ((MssCFGenFileObj)genItem).expandBody( genContext );
			}
			else if( genItem instanceof MssCFGenRuleObj ) {
				retval = ((MssCFGenRuleObj)genItem).expandBody( genContext );
			}
			else if (genItem instanceof MssCFGenTruncObj)
			{
				retval = ((MssCFGenTruncObj)genItem).expandBody( genContext );
			}
			else if (genItem instanceof MssCFGenBindObj)
			{
				retval = ((MssCFGenBindObj)genItem).expandBody( genContext );
			}
			else if( genItem instanceof MssCFGenReferenceObj ) {
				throw new RuntimeException(S_ProcName + &quot;Cannot expand reference &quot; + genItem.getRequiredName() + &quot; directly&quot;);
			}
			else if( genItem instanceof MssCFGenIteratorObj ) {
				retval = ((MssCFGenIteratorObj)genItem).expandBody( genContext );
			}
			else {
				throw new RuntimeException( S_ProcName +  &quot;Unsupported generation item class&quot; );
			}
		}
		else {
			retval = &quot;$$&quot; + getRequiredMacroName() + &quot;$$&quot;;
		}
		return( retval );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	std::string $SchemaName$GelExpansionObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );
		static const std::string S_Dollar( "$$" );
		static const std::string S_ExpectedGenItemClass( "Expected generation item to be one of MssCFGenFileObj, MssCFGenRuleObj, MssCFGenTruncObj, MssCFGenBindObj, MssCFGenReferenceObj, or MssCFGenIterator, not " );
		static const std::string S_CannotExpandReference( "Cannot expand reference \"" );
		static const std::string S_Directly( "\" directly" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		std::string expansion;

		I$SchemaName$GenItemObj* genItem = genContext-&gt;getGenEngine()-&gt;findContextItem( genContext, getRequiredMacroName() );
		if( genItem != NULL ) {

			MssCFGenFileObj* genFileItem = dynamic_cast&lt;MssCFGenFileObj*&gt;( genItem );
			if( genFileItem != NULL ) {
				expansion = genFileItem-&gt;expandBody( genContext );
			}
			else {
				MssCFGenRuleObj* genRuleItem = dynamic_cast&lt;MssCFGenRuleObj*&gt;( genItem );
				if( genRuleItem != NULL ) {
					expansion = genRuleItem-&gt;expandBody( genContext );
				}
				else {
					MssCFGenTruncObj* genTruncItem = dynamic_cast&lt;MssCFGenTruncObj*&gt;( genItem );
					if( genTruncItem != NULL ) {
						expansion = genTruncItem-&gt;expandBody( genContext );
					}
					else {
						MssCFGenBindObj* genBindItem = dynamic_cast&lt;MssCFGenBindObj*&gt;( genItem );
						if( genBindItem != NULL ) {
							expansion = genBindItem-&gt;expandBody( genContext );
						}
						else {
							MssCFGenReferenceObj* genReferenceItem = dynamic_cast&lt;MssCFGenReferenceObj*&gt;( genItem );
							if( genReferenceItem != NULL ) {
								std::string S_Msg( S_CannotExpandReference + genItem-&gt;getRequiredName() + S_Directly );
								throw cflib::CFLibUnsupportedClassException( CLASS_NAME, S_ProcName, S_Msg );
							}
							else {
								MssCFGenIteratorObj* genIteratorItem = dynamic_cast&lt;MssCFGenIteratorObj*&gt;( genItem );
								if( genIteratorItem != NULL ) {
									expansion = genIteratorItem-&gt;expandBody( genContext );
								}
								else {
									std::string S_Msg( S_ExpectedGenItemClass + genItem-&gt;getClassName() );
									throw cflib::CFLibUnsupportedClassException( CLASS_NAME, S_ProcName, S_Msg );
								}
							}
						}
					}
				}
			}
		}
		else {
			expansion.append( S_Dollar + getRequiredMacroName() + S_Dollar );
		}

		genContext-&gt;clearExpansionIsNull();

		return( expansion );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelExpansionEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GelModifier"
			TableClassCode="a930"
			DbName="gelmodifier"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="GelCacheId"
				Label="Source Generation Item GelCache Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="GelInstId"
				Label="GEL Instruction Id"
				IsNullable="false"
				DataType="GelInstructionIdGen" />
		<TableCol Name="RemainderTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="RemainderGelCacheId"
				Label="Source Generation Item GelCache Id"
				IsNullable="false"
				GenerateId="true"
				DataType="RuleCartIdGen" />
		<TableCol Name="RemainderInstId"
				Label="Remainder Instruction Id"
				IsNullable="true"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GelModifierIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="gelmodifier_pidx"
				Suffix="PIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="GelCacheId" IsAscending="true" />
			<IndexCol Name="GelInstId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="GelModifierRemainderInstIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="gelmodifier_xremainder"
				Suffix="RemainderIdx" >
			<IndexCol Name="RemainderTenantId" IsAscending="true" />
			<IndexCol Name="RemainderGelCacheId" IsAscending="true" />
			<IndexCol Name="RemainderInstId" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="gelmodifier_super"
				Suffix="SuperClass"
				FromIndex="GelModifierIdIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public String expand( MssCFGenContext genContext ) {
		throw new RuntimeException( &quot;$SchemaName$GelModifierObj.expand() Must be overloaded by specializing instruction implementation&quot; );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusObjInterface>

		<HPlusObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	std::string $SchemaName$GelModifierObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		throw cflib::CFLibRuntimeException( CLASS_NAME, S_ProcName, "Modifier expand() must be overloaded by subclass" );
	}
</CPlusObjImplementation>

		<CPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext );</CPlusEditObjInterface>

		<HPlusEditObjInterface>
		virtual std::string expand( MssCFGenContext* genContext ) = 0;</HPlusEditObjInterface>

		<CPlusEditObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusEditObjInclude>

		<CPlusEditObjImplementation>
	std::string $SchemaName$GelModifierEditObj::expand( MssCFGenContext* genContext ) {
		static const std::string S_ProcName( "expand" );
		static const std::string S_GenContext( "genContext" );

		if( genContext == NULL ) {
			throw cflib::CFLibNullArgumentException( CLASS_NAME, S_ProcName, 1, S_GenContext );
		}

		static const std::string S_UsageMsg( "You are not allowed to expand an object while it is being edited" );
		throw cflib::CFLibUsageException( CLASS_NAME, S_ProcName, S_UsageMsg );
	}
</CPlusEditObjImplementation>
	</Table>

	<Table Name="GenBind"
			TableClassCode="a931"
			DbName="kbgenbind"
			Label="Generation Binding"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Insert"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="CartridgeId"
				Label="Cartridge Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="ItemId"
				Label="Item Id"
				IsNullable="false"
				DataType="GenItemIdGen" />
		<PrimaryIndex Name="GenBindIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbgbind_xid"
				Suffix="IdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="CartridgeId" IsAscending="true" />
			<IndexCol Name="ItemId" IsAscending="true" />
		</PrimaryIndex>
		<SuperClassRelation Name="SuperClass"
				DbName="kbgbind_super"
				Suffix="SuperClass"
				FromIndex="GenBindIdIdx"
				ToIndex="GenItem.GenItemIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="CartridgeId" ToCol="CartridgeId" />
			<RelationCol Name="ItemId" ToCol="ItemId" />
		</SuperClassRelation>
	</Table>

	<Table Name="GenFile"
			TableClassCode="a932"
			DbName="kbgenfile"
			Label="Generation File"
			IsInstantiable="true"
			HasHistory="false"
			HasAuditColumns="false"
			LoaderBehaviour="Update"
			SecScope="Tenant" >
		<TableCol Name="TenantId"
				IsNullable="false"
				DataType="TenantIdGen" />
		<TableCol Name="CartridgeId"
				Label="Cartridge Id"
				IsNullable="false"
				DataType="RuleCartIdGen" />
		<TableCol Name="ItemId"
				Label="Item Id"
				IsNullable="false"
				DataType="GenItemIdGen" />
		<StringCol Name="GenerateOnce"
				ShortName="GenOnce"
				Label="Generate Once"
				DbName="gen_once"
				IsNullable="true"
				MaxLen="8"
				InitValue="" />
		<StringCol Name="SourceBundle"
				ShortName="SrcBndl"
				Label="Source Bundle"
				IsNullable="true"
				MaxLen="1024"
				InitValue="" />
		<TableCol Name="SourceBundleTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="SourceBundleGelCacheId"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="SourceBundleGelId"
				IsNullable="true"
				DbName="srcbundle_gelid"
				DataType="GelInstructionIdGen" />
		<StringCol Name="ModuleName"
				IsNullable="true"
				DbName="mod_name"
				MaxLen="1024"
				InitValue="" />
		<TableCol Name="ModuleNameTenantId"
				IsNullable="true"
				DbName="modname_tent"
				DataType="TenantIdGen" />
		<TableCol Name="ModuleNameGelCacheId"
				DbName="modname_cart"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="ModuleNameGelId"
				IsNullable="true"
				DbName="modname_gelid"
				DataType="GelInstructionIdGen" />
		<StringCol Name="BasePackageName"
				Label="Base Package Name"
				IsNullable="true"
				MaxLen="1024"
				InitValue="" />
		<TableCol Name="BasePackageTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="BasePackageGelCacheId"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="BasePackageGelId"
				IsNullable="true"
				DbName="basepkg_gelid"
				DataType="GelInstructionIdGen" />
		<StringCol Name="SubPackageName"
				Label="Sub Package Name"
				IsNullable="true"
				MaxLen="1024"
				InitValue="" />
		<TableCol Name="SubPackageTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="SubPackageGelCacheId"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="SubPackageGelId"
				IsNullable="true"
				DbName="subpkg_gelid"
				DataType="GelInstructionIdGen" />
		<StringCol Name="ExpansionClassName"
				Label="Expansion Class Name"
				IsNullable="true"
				MaxLen="1024"
				InitValue="" />
		<TableCol Name="ExpansionClassNameTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="ExpansionClassNameGelCacheId"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="ExpansionClassNameGelId"
				IsNullable="true"
				DbName="expclsnm_gelid"
				DataType="GelInstructionIdGen" />
		<StringCol Name="ExpansionKeyName"
				Label="Expansion Key Name"
				IsNullable="true"
				MaxLen="1024"
				InitValue="" />
		<TableCol Name="ExpansionKeyNameTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="ExpansionKeyNameGelCacheId"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="ExpansionKeyNameGelId"
				IsNullable="true"
				DbName="expkeynm_gelid"
				DataType="GelInstructionIdGen" />
		<StringCol Name="ExpansionFileName"
				Label="Expansion File Name"
				IsNullable="true"
				MaxLen="1024"
				InitValue="" />
		<TableCol Name="ExpansionFileNameTenantId"
				IsNullable="true"
				DataType="TenantIdGen" />
		<TableCol Name="ExpansionFileNameGelCacheId"
				IsNullable="true"
				DataType="GelCacheIdGen" />
		<TableCol Name="ExpansionFileNameGelId"
				IsNullable="true"
				DbName="expfilenm_gelid"
				DataType="GelInstructionIdGen" />
		<PrimaryIndex Name="GenFileIdIdx"
				IsDbMapped="true"
				IsUnique="true"
				DbName="kbgenfile_id"
				Suffix="IdIdx" >
			<IndexCol Name="TenantId" IsAscending="true" />
			<IndexCol Name="CartridgeId" IsAscending="true" />
			<IndexCol Name="ItemId" IsAscending="true" />
		</PrimaryIndex>
		<Index Name="SourceBundleIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="genfile_srcbdlidx"
				Suffix="XSrcBundle" >
			<IndexCol Name="SourceBundleTenantId" IsAscending="true" />
			<IndexCol Name="SourceBundleGelCacheId" IsAscending="true" />
			<IndexCol Name="SourceBundleGelId" IsAscending="true" />
		</Index>
		<Index Name="ModuleNameIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="modname_gelidx"
				Suffix="XModName" >
			<IndexCol Name="ModuleNameTenantId" IsAscending="true" />
			<IndexCol Name="ModuleNameGelCacheId" IsAscending="true" />
			<IndexCol Name="ModuleNameGelId" IsAscending="true" />
		</Index>
		<Index Name="BasePackageIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="basepkg_gelidx"
				Suffix="XBasePkg" >
			<IndexCol Name="BasePackageTenantId" IsAscending="true" />
			<IndexCol Name="BasePackageGelCacheId" IsAscending="true" />
			<IndexCol Name="BasePackageGelId" IsAscending="true" />
		</Index>
		<Index Name="SubPackageIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="subpkg_gelidx"
				Suffix="XSubPkg" >
			<IndexCol Name="SubPackageTenantId" IsAscending="true" />
			<IndexCol Name="SubPackageGelCacheId" IsAscending="true" />
			<IndexCol Name="SubPackageGelId" IsAscending="true" />
		</Index>
		<Index Name="ExpansionClassNameIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="expclsnm_gelidx"
				Suffix="XExpClsName" >
			<IndexCol Name="ExpansionClassNameTenantId" IsAscending="true" />
			<IndexCol Name="ExpansionClassNameGelCacheId" IsAscending="true" />
			<IndexCol Name="ExpansionClassNameGelId" IsAscending="true" />
		</Index>
		<Index Name="ExpansionKeyNameIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="expkeynm_gelidx"
				Suffix="XExpKeyName" >
			<IndexCol Name="ExpansionKeyNameTenantId" IsAscending="true" />
			<IndexCol Name="ExpansionKeyNameGelCacheId" IsAscending="true" />
			<IndexCol Name="ExpansionKeyNameGelId" IsAscending="true" />
		</Index>
		<Index Name="ExpansionFileNameIdx"
				IsDbMapped="true"
				IsUnique="false"
				DbName="expfilenm_gelidx"
				Suffix="XExpFileName" >
			<IndexCol Name="ExpansionFileNameTenantId" IsAscending="true" />
			<IndexCol Name="ExpansionFileNameGelCacheId" IsAscending="true" />
			<IndexCol Name="ExpansionFileNameGelId" IsAscending="true" />
		</Index>
		<SuperClassRelation Name="SuperClass"
				DbName="expfilenm_super"
				Suffix="SuperClass"
				FromIndex="GenFileIdIdx"
				ToIndex="GenRule.GenRuleIdIdx" >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="CartridgeId" ToCol="CartridgeId" />
			<RelationCol Name="ItemId" ToCol="ItemId" />
		</SuperClassRelation>

		<CafeObjImport>
import com.github.msobkow.cfcore.MssCF.MssCFEngine;
import com.github.msobkow.cfcore.MssCF.MssCFGelCompiler;
import com.github.msobkow.cfcore.MssCF.MssCFGenContext;</CafeObjImport>

		<CafeObjImplementation>
	public static I$SchemaName$GelExecutableObj getSrcBundleBin( MssCFGelCompiler gelCompiler, I$SchemaName$GenFileObj genFile ) {
		final String S_ProcName = &quot;$SchemaName$GenFileObj.getSrcBundleBin() &quot;;
		I$SchemaName$GelExecutableObj bin = genFile.getOptionalComponentsSrcBundleGel();
		if( bin == null ) {
			String execName = genFile.getRequiredLookupToolSet().getRequiredName()
				+ "::" + genFile.getRequiredLookupRuleType().getRequiredName()
				+ "::" + (( genFile.getOptionalLookupScopeDef() == null ) ? "Object" : genFile.getOptionalLookupScopeDef().getRequiredName() )
				+ "::" + genFile.getRequiredLookupGenDef().getRequiredName()
				+ "::" + genFile.getRequiredName()
				+ "::SrcBundle";
			String source = genFile.getOptionalSourceBundle();
			bin = gelCompiler.compileExecutable( execName, source );
			if( bin == null ) {
				throw new RuntimeException( S_ProcName + &quot;Could not compile SrcBundle GEL executable from source \&quot;&quot; + source + &quot;\&quot;&quot; );
			}

			I$SchemaName$GenFileEditObj editFile = genFile.getEditAsGenFile();
			if( editFile != null ) {
				editFile.setOptionalComponentsSrcBundleGel( bin );
			}
			else {
				editFile = (I$SchemaName$GenFileEditObj)genFile.beginEdit();
				editFile.setOptionalComponentsSrcBundleGel( bin );
				editFile.update();
				editFile = null;
			}
		}
		return( bin );
	}

	public static I$SchemaName$GelExecutableObj getBasePackageBin( MssCFGelCompiler gelCompiler, I$SchemaName$GenFileObj genFile ) {
		final String S_ProcName = &quot;$SchemaName$GenFileObj.getBasePackageBin() &quot;;
		I$SchemaName$GelExecutableObj bin = genFile.getOptionalComponentsBasePackageGel();
		if( bin == null ) {
			String execName = genFile.getRequiredLookupToolSet().getRequiredName()
				+ "::" + genFile.getRequiredLookupRuleType().getRequiredName()
				+ "::" + (( genFile.getOptionalLookupScopeDef() == null ) ? "Object" : genFile.getOptionalLookupScopeDef().getRequiredName() )
				+ "::" + genFile.getRequiredLookupGenDef().getRequiredName()
				+ "::" + genFile.getRequiredName()
				+ "::BasePackage";
			String source = genFile.getOptionalBasePackageName();
			bin = gelCompiler.compileExecutable( execName, source );
			if( bin == null ) {
				throw new RuntimeException( S_ProcName + &quot;Could not compile BasePackageName GEL executable from source \&quot;&quot; + source + &quot;\&quot;&quot; );
			}

			I$SchemaName$GenFileEditObj editFile = genFile.getEditAsGenFile();
			if( editFile != null ) {
				editFile.setOptionalComponentsBasePackageGel( bin );
			}
			else {
				editFile = (I$SchemaName$GenFileEditObj)genFile.beginEdit();
				editFile.setOptionalComponentsBasePackageGel( bin );
				editFile.update();
				editFile = null;
			}
		}
		return( bin );
	}

	public static I$SchemaName$GelExecutableObj getModuleNameBin( MssCFGelCompiler gelCompiler, I$SchemaName$GenFileObj genFile ) {
		final String S_Empty = &quot;&quot;;
		final String S_ProcName = &quot;$SchemaName$GenFileObj.getModuleNameBin() &quot;;
		I$SchemaName$GelExecutableObj bin = genFile.getOptionalComponentsModuleNameGel();
		if( bin == null ) {
			String execName = genFile.getRequiredLookupToolSet().getRequiredName()
				+ "::" + genFile.getRequiredLookupRuleType().getRequiredName()
				+ "::" + (( genFile.getOptionalLookupScopeDef() == null ) ? "Object" : genFile.getOptionalLookupScopeDef().getRequiredName() )
				+ "::" + genFile.getRequiredLookupGenDef().getRequiredName()
				+ "::" + genFile.getRequiredName()
				+ "::ModuleName";
			String source = genFile.getOptionalModuleName();
			if( source == null ) {
				source = S_Empty;
			}

			bin = gelCompiler.compileExecutable( execName, source );
			if( bin == null ) {
				throw new RuntimeException( S_ProcName + &quot;Could not compile ModuleName GEL executable from source \&quot;&quot; + source + &quot;\&quot;&quot; );
			}

			I$SchemaName$GenFileEditObj editFile = genFile.getEditAsGenFile();
			if( editFile != null ) {
				editFile.setOptionalComponentsModuleNameGel( bin );
			}
			else {
				editFile = (I$SchemaName$GenFileEditObj)genFile.beginEdit();
				editFile.setOptionalComponentsModuleNameGel( bin );
				editFile.update();
				editFile = null;
			}
		}
		return( bin );
	}

	public static I$SchemaName$GelExecutableObj getSubPackageBin( MssCFGelCompiler gelCompiler, I$SchemaName$GenFileObj genFile ) {
		final String S_ProcName = &quot;$SchemaName$GenFileObj.getSubPackageBin() &quot;;
		I$SchemaName$GelExecutableObj bin = genFile.getOptionalComponentsSubPackageGel();
		if( bin == null ) {
			String execName = genFile.getRequiredLookupToolSet().getRequiredName()
				+ "::" + genFile.getRequiredLookupRuleType().getRequiredName()
				+ "::" + (( genFile.getOptionalLookupScopeDef() == null ) ? "Object" : genFile.getOptionalLookupScopeDef().getRequiredName() )
				+ "::" + genFile.getRequiredLookupGenDef().getRequiredName()
				+ "::" + genFile.getRequiredName()
				+ "::SubPackage";
			String source = genFile.getOptionalSubPackageName();
			bin = gelCompiler.compileExecutable( execName, source );
			if( bin == null ) {
				throw new RuntimeException( S_ProcName + &quot;Could not compile SubPackage GEL executable from source \&quot;&quot; + source + &quot;\&quot;&quot; );
			}

			I$SchemaName$GenFileEditObj editFile = genFile.getEditAsGenFile();
			if( editFile != null ) {
				editFile.setOptionalComponentsSubPackageGel( bin );
			}
			else {
				editFile = (I$SchemaName$GenFileEditObj)genFile.beginEdit();
				editFile.setOptionalComponentsSubPackageGel( bin );
				editFile.update();
				editFile = null;
			}
		}
		return( bin );
	}

	public static I$SchemaName$GelExecutableObj getExpClassBin( MssCFGelCompiler gelCompiler, I$SchemaName$GenFileObj genFile ) {
		final String S_ProcName = &quot;$SchemaName$GenFileObj.getExpClassBin() &quot;;
		I$SchemaName$GelExecutableObj bin = genFile.getOptionalComponentsExpClassGel();
		if( bin == null ) {
			String execName = genFile.getRequiredLookupToolSet().getRequiredName()
				+ "::" + genFile.getRequiredLookupRuleType().getRequiredName()
				+ "::" + (( genFile.getOptionalLookupScopeDef() == null ) ? "Object" : genFile.getOptionalLookupScopeDef().getRequiredName() )
				+ "::" + genFile.getRequiredLookupGenDef().getRequiredName()
				+ "::" + genFile.getRequiredName()
				+ "::ExpClass";
			String source = genFile.getOptionalExpansionClassName();
			bin = gelCompiler.compileExecutable( execName, source );
			if( bin == null ) {
				throw new RuntimeException( S_ProcName + &quot;Could not compile ExpClass GEL executable from source \&quot;&quot; + source + &quot;\&quot;&quot; );
			}

			I$SchemaName$GenFileEditObj editFile = genFile.getEditAsGenFile();
			if( editFile != null ) {
				editFile.setOptionalComponentsExpClassGel( bin );
			}
			else {
				editFile = (I$SchemaName$GenFileEditObj)genFile.beginEdit();
				editFile.setOptionalComponentsExpClassGel( bin );
				editFile.update();
				editFile = null;
			}
		}
		return( bin );
	}

	public static I$SchemaName$GelExecutableObj getExpKeyNameBin( MssCFGelCompiler gelCompiler, I$SchemaName$GenFileObj genFile ) {
		final String S_ProcName = &quot;$SchemaName$GenFileObj.getExpKeyNameBin() &quot;;
		I$SchemaName$GelExecutableObj bin = genFile.getOptionalComponentsExpKeyNameGel();
		if( bin == null ) {
			String execName = genFile.getRequiredLookupToolSet().getRequiredName()
				+ "::" + genFile.getRequiredLookupRuleType().getRequiredName()
				+ "::" + (( genFile.getOptionalLookupScopeDef() == null ) ? "Object" : genFile.getOptionalLookupScopeDef().getRequiredName() )
				+ "::" + genFile.getRequiredLookupGenDef().getRequiredName()
				+ "::" + genFile.getRequiredName()
				+ "::ExpKeyName";
			String source = genFile.getOptionalExpansionKeyName();
			bin = gelCompiler.compileExecutable( execName, source );
			if( bin == null ) {
				throw new RuntimeException( S_ProcName + &quot;Could not compile ExpKeyName GEL executable from source \&quot;&quot; + source + &quot;\&quot;&quot; );
			}

			I$SchemaName$GenFileEditObj editFile = genFile.getEditAsGenFile();
			if( editFile != null ) {
				editFile.setOptionalComponentsExpKeyNameGel( bin );
			}
			else {
				editFile = (I$SchemaName$GenFileEditObj)genFile.beginEdit();
				editFile.setOptionalComponentsExpKeyNameGel( bin );
				editFile.update();
				editFile = null;
			}
		}
		return( bin );
	}

	public static I$SchemaName$GelExecutableObj getExpFileNameBin( MssCFGelCompiler gelCompiler, I$SchemaName$GenFileObj genFile ) {
		final String S_ProcName = &quot;$SchemaName$GenFileObj.getExpFileNameBin() &quot;;
		I$SchemaName$GelExecutableObj bin = genFile.getOptionalComponentsExpFileNameGel();
		if( bin == null ) {
			String execName = genFile.getRequiredLookupToolSet().getRequiredName()
				+ "::" + genFile.getRequiredLookupRuleType().getRequiredName()
				+ "::" + (( genFile.getOptionalLookupScopeDef() == null ) ? "Object" : genFile.getOptionalLookupScopeDef().getRequiredName() )
				+ "::" + genFile.getRequiredLookupGenDef().getRequiredName()
				+ "::" + genFile.getRequiredName()
				+ "::ExpansionFileName";
			String source = genFile.getOptionalExpansionFileName();
			bin = gelCompiler.compileExecutable( execName, source );
			if( bin == null ) {
				throw new RuntimeException( S_ProcName + &quot;Could not compile ExpFileName GEL executable from source \&quot;&quot; + source + &quot;\&quot;&quot; );
			}

			I$SchemaName$GenFileEditObj editFile = genFile.getEditAsGenFile();
			if( editFile != null ) {
				editFile.setOptionalComponentsExpFileNameGel( bin );
			}
			else {
				editFile = (I$SchemaName$GenFileEditObj)genFile.beginEdit();
				editFile.setOptionalComponentsExpFileNameGel( bin );
				editFile.update();
				editFile = null;
			}
		}
		return( bin );
	}
</CafeObjImplementation>

		<CPlusObjInterface>
		static I$SchemaName$GelExecutableObj* getSrcBundleBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile );
		static I$SchemaName$GelExecutableObj* getBasePackageBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile );
		static I$SchemaName$GelExecutableObj* getModuleNameBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile );
		static I$SchemaName$GelExecutableObj* getSubPackageBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile );
		static I$SchemaName$GelExecutableObj* getExpClassBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile );
		static I$SchemaName$GelExecutableObj* getExpKeyNameBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile );
		static I$SchemaName$GelExecutableObj* getExpFileNameBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile );</CPlusObjInterface>

		<HPlusObjInterface></HPlusObjInterface>

		<CPlusObjInclude>

namespace cfcore {
	class MssCFEngine;
	class MssCFGenContext;
	class MssCFGelCompiler;
	class MssCFGenFileObj;
	class MssCFGenRuleObj;
	class MssCFGenTruncObj;
	class MssCFGenBindObj;
	class MssCFGenReferenceObj;
	class MssCFGenIteratorObj;
}
</CPlusObjInclude>

		<CPlusObjImplementation>
}

#include &lt;msscf/MssCFEngine.hpp&gt;
#include &lt;msscf/MssCFGenContext.hpp&gt;
#include &lt;msscf/MssCFGenContextFactory.hpp&gt;
#include &lt;msscf/MssCFGelCompiler.hpp&gt;
#include &lt;msscf/MssCFGenFileObj.hpp&gt;
#include &lt;msscf/MssCFGenRuleObj.hpp&gt;
#include &lt;msscf/MssCFGenTruncObj.hpp&gt;
#include &lt;msscf/MssCFGenBindObj.hpp&gt;
#include &lt;msscf/MssCFGenReferenceObj.hpp&gt;
#include &lt;msscf/MssCFGenIteratorObj.hpp&gt;

namespace cfcore {

	I$SchemaName$GelExecutableObj* $SchemaName$GenFileObj::getSrcBundleBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile ) {
		static const std::string S_ProcName( "GenFileObj.getSrcBundleBin" );
		static const std::string S_Empty( "" );
		static const std::string S_CouldNotCompileGel( "Could not compile SrcBundle GEL executable from source \"" );
		static const std::string S_DQuote( "\" near " );
		static const std::string S_Dash( " - " );
		static const std::string S_ColonColon( "::" );
		static const std::string S_Object( "Object" );
		static const std::string S_ColonColonSrcBundle( "::SrcBundle" );
		I$SchemaName$GelExecutableObj* bin = genFile-&gt;getOptionalComponentsSrcBundleGel();
		if( bin == NULL ) {
			std::string execName( genFile-&gt;getRequiredLookupToolSet()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupRuleType()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( ( genFile-&gt;getOptionalLookupScopeDef() == NULL ) ? std::string( S_Object ) : genFile-&gt;getOptionalLookupScopeDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupGenDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredName() );
			execName.append( S_ColonColonSrcBundle );
			const std::string* source = genFile-&gt;getOptionalSourceBundleReference();
			if( source == NULL ) {
				source = &amp;S_Empty;
			}
			bin = gelCompiler-&gt;compileExecutable( execName, *source );
			I$SchemaName$GenFileEditObj* editFile = genFile-&gt;getGenFileEdit();
			if( editFile != NULL ) {
				editFile-&gt;setOptionalComponentsSrcBundleGel( bin );
			}
			else {
				editFile = dynamic_cast&lt;I$SchemaName$GenFileEditObj*&gt;( genFile-&gt;beginEdit() );
				editFile-&gt;setOptionalComponentsSrcBundleGel( bin );
				editFile-&gt;update();
				editFile = NULL;
			}
		}
		return( bin );
	}

	I$SchemaName$GelExecutableObj* $SchemaName$GenFileObj::getBasePackageBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile ) {
		static const std::string S_ProcName( "GenFileObj.getBasePackageBin" );
		static const std::string S_Empty( "" );
		static const std::string S_CouldNotCompileGel( "Could not compile BasePackage GEL executable from source \"" );
		static const std::string S_DQuote( "\" near " );
		static const std::string S_Dash( " - " );
		static const std::string S_ColonColon( "::" );
		static const std::string S_Object( "Object" );
		static const std::string S_ColonColonBasePackage( "::BasePackage" );
		I$SchemaName$GelExecutableObj* bin = genFile-&gt;getOptionalComponentsBasePackageGel();
		if( bin == NULL ) {
			std::string execName( genFile-&gt;getRequiredLookupToolSet()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupRuleType()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( ( genFile-&gt;getOptionalLookupScopeDef() == NULL ) ? std::string( S_Object ) : genFile-&gt;getOptionalLookupScopeDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupGenDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredName() );
			execName.append( S_ColonColonBasePackage );
			const std::string* source = genFile-&gt;getOptionalBasePackageNameReference();
			if( source == NULL ) {
				source = &amp;S_Empty;
			}
			bin = gelCompiler-&gt;compileExecutable( execName, *source );
			I$SchemaName$GenFileEditObj* editFile = genFile-&gt;getGenFileEdit();
			if( editFile != NULL ) {
				editFile-&gt;setOptionalComponentsBasePackageGel( bin );
			}
			else {
				editFile = dynamic_cast&lt;I$SchemaName$GenFileEditObj*&gt;( genFile-&gt;beginEdit() );
				editFile-&gt;setOptionalComponentsBasePackageGel( bin );
				editFile-&gt;update();
				editFile = NULL;
			}
		}
		return( bin );
	}

	I$SchemaName$GelExecutableObj* $SchemaName$GenFileObj::getModuleNameBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile ) {
		static const std::string S_ProcName( "GenFileObj.getModuleNameBin" );
		static const std::string S_Empty( "" );
		static const std::string S_CouldNotCompileGel( "Could not compile ModuleName GEL executable from source \"" );
		static const std::string S_DQuote( "\" near " );
		static const std::string S_Dash( " - " );
		static const std::string S_ColonColon( "::" );
		static const std::string S_Object( "Object" );
		static const std::string S_ColonColonModuleName( "::ModuleName" );
		I$SchemaName$GelExecutableObj* bin = genFile-&gt;getOptionalComponentsModuleNameGel();
		if( bin == NULL ) {
			std::string execName( genFile-&gt;getRequiredLookupToolSet()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupRuleType()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( ( genFile-&gt;getOptionalLookupScopeDef() == NULL ) ? std::string( S_Object ) : genFile-&gt;getOptionalLookupScopeDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupGenDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredName() );
			execName.append( S_ColonColonModuleName );
			const std::string* source = genFile-&gt;getOptionalModuleNameReference();
			if( source == NULL ) {
				source = &amp;S_Empty;
			}
			bin = gelCompiler-&gt;compileExecutable( execName, *source );
			I$SchemaName$GenFileEditObj* editFile = genFile-&gt;getGenFileEdit();
			if( editFile != NULL ) {
				editFile-&gt;setOptionalComponentsModuleNameGel( bin );
			}
			else {
				editFile = dynamic_cast&lt;I$SchemaName$GenFileEditObj*&gt;( genFile-&gt;beginEdit() );
				editFile-&gt;setOptionalComponentsModuleNameGel( bin );
				editFile-&gt;update();
				editFile = NULL;
			}
		}
		return( bin );
	}

	I$SchemaName$GelExecutableObj* $SchemaName$GenFileObj::getSubPackageBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile ) {
		static const std::string S_ProcName( "GenFileObj.getSubPackageBinBin" );
		static const std::string S_Empty( "" );
		static const std::string S_CouldNotCompileGel( "Could not compile SubPackage GEL executable from source \"" );
		static const std::string S_DQuote( "\" near " );
		static const std::string S_Dash( " - " );
		static const std::string S_ColonColon( "::" );
		static const std::string S_Object( "Object" );
		static const std::string S_ColonColonSubPackage( "::SubPackage" );
		I$SchemaName$GelExecutableObj* bin = genFile-&gt;getOptionalComponentsSubPackageGel();
		if( bin == NULL ) {
			std::string execName( genFile-&gt;getRequiredLookupToolSet()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupRuleType()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( ( genFile-&gt;getOptionalLookupScopeDef() == NULL ) ? std::string( S_Object ) : genFile-&gt;getOptionalLookupScopeDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupGenDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredName() );
			execName.append( S_ColonColonSubPackage );
			const std::string* source = genFile-&gt;getOptionalSubPackageNameReference();
			if( source == NULL ) {
				source = &amp;S_Empty;
			}
			bin = gelCompiler-&gt;compileExecutable( execName, *source );
			I$SchemaName$GenFileEditObj* editFile = genFile-&gt;getGenFileEdit();
			if( editFile != NULL ) {
				editFile-&gt;setOptionalComponentsSubPackageGel( bin );
			}
			else {
				editFile = dynamic_cast&lt;I$SchemaName$GenFileEditObj*&gt;( genFile-&gt;beginEdit() );
				editFile-&gt;setOptionalComponentsSubPackageGel( bin );
				editFile-&gt;update();
				editFile = NULL;
			}
		}
		return( bin );
	}

	I$SchemaName$GelExecutableObj* $SchemaName$GenFileObj::getExpClassBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile ) {
		static const std::string S_ProcName( "GenFileObj.getExpClassBin" );
		static const std::string S_Empty( "" );
		static const std::string S_CouldNotCompileGel( "Could not compile ExpClass GEL executable from source \"" );
		static const std::string S_DQuote( "\" near " );
		static const std::string S_Dash( " - " );
		static const std::string S_ColonColon( "::" );
		static const std::string S_Object( "Object" );
		static const std::string S_ColonColonExpClass( "::ExpClass" );
		I$SchemaName$GelExecutableObj* bin = genFile-&gt;getOptionalComponentsExpClassGel();
		if( bin == NULL ) {
			std::string execName( genFile-&gt;getRequiredLookupToolSet()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupRuleType()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( ( genFile-&gt;getOptionalLookupScopeDef() == NULL ) ? std::string( S_Object ) : genFile-&gt;getOptionalLookupScopeDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupGenDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredName() );
			execName.append( S_ColonColonExpClass );
			const std::string* source = genFile-&gt;getOptionalExpansionClassNameReference();
			if( source == NULL ) {
				source = &amp;S_Empty;
			}
			bin = gelCompiler-&gt;compileExecutable( execName, *source );
			I$SchemaName$GenFileEditObj* editFile = genFile-&gt;getGenFileEdit();
			if( editFile != NULL ) {
				editFile-&gt;setOptionalComponentsExpClassGel( bin );
			}
			else {
				editFile = dynamic_cast&lt;I$SchemaName$GenFileEditObj*&gt;( genFile-&gt;beginEdit() );
				editFile-&gt;setOptionalComponentsExpClassGel( bin );
				editFile-&gt;update();
				editFile = NULL;
			}
		}
		return( bin );
	}

	I$SchemaName$GelExecutableObj* $SchemaName$GenFileObj::getExpKeyNameBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile ) {
		static const std::string S_ProcName( "GenFileObj.getExpKeyNameBin" );
		static const std::string S_Empty( "" );
		static const std::string S_CouldNotCompileGel( "Could not compile ExpKeyName GEL executable from source \"" );
		static const std::string S_DQuote( "\" near " );
		static const std::string S_Dash( " - " );
		static const std::string S_ColonColon( "::" );
		static const std::string S_Object( "Object" );
		static const std::string S_ColonColonExpKeyName( "::ExpKeyName" );
		I$SchemaName$GelExecutableObj* bin = genFile-&gt;getOptionalComponentsExpKeyNameGel();
		if( bin == NULL ) {
			std::string execName( genFile-&gt;getRequiredLookupToolSet()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupRuleType()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( ( genFile-&gt;getOptionalLookupScopeDef() == NULL ) ? std::string( S_Object ) : genFile-&gt;getOptionalLookupScopeDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupGenDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredName() );
			execName.append( S_ColonColonExpKeyName );
			const std::string* source = genFile-&gt;getOptionalExpansionKeyNameReference();
			if( source == NULL ) {
				source = &amp;S_Empty;
			}
			bin = gelCompiler-&gt;compileExecutable( execName, *source );
			I$SchemaName$GenFileEditObj* editFile = genFile-&gt;getGenFileEdit();
			if( editFile != NULL ) {
				editFile-&gt;setOptionalComponentsExpKeyNameGel( bin );
			}
			else {
				editFile = dynamic_cast&lt;I$SchemaName$GenFileEditObj*&gt;( genFile-&gt;beginEdit() );
				editFile-&gt;setOptionalComponentsExpKeyNameGel( bin );
				editFile-&gt;update();
				editFile = NULL;
			}
		}
		return( bin );
	}

	I$SchemaName$GelExecutableObj* $SchemaName$GenFileObj::getExpFileNameBin( MssCFGelCompiler* gelCompiler, I$SchemaName$GenFileObj* genFile ) {
		static const std::string S_ProcName( "GenFileObj.getExpFileNameBin" );
		static const std::string S_Empty( "" );
		static const std::string S_CouldNotCompileGel( "Could not compile ExpFileName GEL executable from source \"" );
		static const std::string S_DQuote( "\" near " );
		static const std::string S_Dash( " - " );
		static const std::string S_ColonColon( "::" );
		static const std::string S_Object( "Object" );
		static const std::string S_ColonColonExpFileName( "::ExpFileName" );
		I$SchemaName$GelExecutableObj* bin = genFile-&gt;getOptionalComponentsExpFileNameGel();
		if( bin == NULL ) {
			std::string execName( genFile-&gt;getRequiredLookupToolSet()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupRuleType()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( ( genFile-&gt;getOptionalLookupScopeDef() == NULL ) ? std::string( S_Object ) : genFile-&gt;getOptionalLookupScopeDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredLookupGenDef()-&gt;getRequiredName() );
			execName.append( S_ColonColon );
			execName.append( genFile-&gt;getRequiredName() );
			execName.append( S_ColonColonExpFileName );
			const std::string* source = genFile-&gt;getOptionalExpansionFileNameReference();
			if( source == NULL ) {
				source = &amp;S_Empty;
			}
			bin = gelCompiler-&gt;compileExecutable( execName, *source );
			I$SchemaName$GenFileEditObj* editFile = genFile-&gt;getGenFileEdit();
			if( editFile != NULL ) {
				editFile-&gt;setOptionalComponentsExpFileNameGel( bin );
			}
			else {
				editFile = dynamic_cast&lt;I$SchemaName$GenFileEditObj*&gt;( genFile-&gt;beginEdit() );
				editFile-&gt;setOptionalComponentsExpFileNameGel( bin );
				editFile-&gt;update();
				editFile = NULL;
			}
		}
		return( bin );
	}
</CPlusObjImplementation>
	</Table>

	<TableAddendum FromTable="DefClass">
		<Relation Name="BaseDefClass"
				RelationType="Parent"
				DbName="defcls_basedefcls"
				Label="BaseDefClass"
				Suffix="BaseDefClass"
				FromIndex="DefClassBaseIdx"
				ToIndex="DefClass.DefClassIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="BaseId" ToCol="Id" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelConstrain">
		<Relation Name="Remainder"
				RelationType="Lookup"
				DbName="gelcons_remdr"
				Label="Called GEL Instructions"
				Suffix="Remainder"
				FromIndex="GelConstrainRemainderInstIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="RemainderTenantId" ToCol="TenantId" />
			<RelationCol Name="RemainderGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="RemainderInstId" ToCol="GelInstId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelExecutable">
	</TableAddendum>

	<TableAddendum FromTable="GelCache">
		<Relation Name="Tenant"
				RelationType="Owner"
				DbName="gelcache_gtenant"
				Label="Tenant"
				Suffix="Tenant"
				FromIndex="GelCacheTenantIdx"
				ToIndex="Tenant.TenantIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="Id" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelInstruction">
		<Relation Name="Tenant"
				RelationType="Owner"
				DbName="gelinst_gtenant"
				Label="Tenant"
				Suffix="Tenant"
				FromIndex="GelInstructionTenantIdx"
				ToIndex="Tenant.TenantIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="Id" />
		</Relation>
		<Relation Name="GelCache"
				RelationType="Container"
				DbName="gelinst_gcache"
				Label="GEL Cache"
				Suffix="GelCache"
				FromIndex="GelInstructionGelCacheIdx"
				ToIndex="GelCache.GelCacheIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
		</Relation>
		<Relation Name="ChainInst"
				RelationType="Lookup"
				DbName="gelinst_rchaininst"
				Label="Chain cached instruction"
				Suffix="ChainInst"
				FromIndex="GelInstructionChainInstIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="ChainInstTenantId" ToCol="TenantId" />
			<RelationCol Name="ChainInstGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="ChainInstGelInstId" ToCol="GelInstId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelCall">
		<Relation Name="SeqInst"
				RelationType="Parent"
				DbName="gelcall_rcontseq"
				Label="Parent Sequence Instruction"
				Suffix="SeqInst"
				FromIndex="GelCallSequenceIdx"
				ToIndex="GelSequence.GelSequenceIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="SeqInstTenantId" ToCol="TenantId" />
			<RelationCol Name="SeqInstGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="SeqInstId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="CallInst"
				RelationType="Lookup"
				DbName="gelcall_rcallinst"
				Label="Call cached instruction"
				Suffix="CallInst"
				FromIndex="GelCallCallInstIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="CallInstTenantId" ToCol="TenantId" />
			<RelationCol Name="CallInstGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="CallInstId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="PrevInst"
				RelationType="Lookup"
				DbName="gelcall_rprev"
				Label="Prev call instruction"
				Suffix="PrevInst"
				FromIndex="GelCallPrevInstIdx"
				ToIndex="GelCall.GelCallIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="PrevInstTenantId" ToCol="TenantId" />
			<RelationCol Name="PrevInstGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="PrevInstGelInstId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="NextInst"
				RelationType="Lookup"
				DbName="gelcall_rnext"
				Label="Next call instruction"
				Suffix="NextInst"
				FromIndex="GelCallNextInstIdx"
				ToIndex="GelCall.GelCallIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="NextInstTenantId" ToCol="TenantId" />
			<RelationCol Name="NextInstGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="NextInstGelInstId" ToCol="GelInstId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelModifier">
		<Relation Name="Remainder"
				RelationType="Lookup"
				DbName="gelmod_remdr"
				Label="Called GEL Instructions"
				Suffix="Remainder"
				FromIndex="GelModifierRemainderInstIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="RemainderTenantId" ToCol="TenantId" />
			<RelationCol Name="RemainderGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="RemainderInstId" ToCol="GelInstId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelPop">
		<Relation Name="Remainder"
				RelationType="Lookup"
				DbName="gelpop_remdr"
				Label="Called GEL Instructions"
				Suffix="Remainder"
				FromIndex="GelPopRemainderInstIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="RemainderTenantId" ToCol="TenantId" />
			<RelationCol Name="RemainderGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="RemainderInstId" ToCol="GelInstId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelPrefixLine">
		<Relation Name="Remainder"
				RelationType="Lookup"
				DbName="gelpfxln_remdr"
				Label="Called GEL Instructions"
				Suffix="Remainder"
				FromIndex="GelPrefixLineRemainderInstIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="RemainderTenantId" ToCol="TenantId" />
			<RelationCol Name="RemainderGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="RemainderInstId" ToCol="GelInstId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelReference">
		<Relation Name="Remainder"
				RelationType="Lookup"
				DbName="gelref_remdr"
				Label="Called GEL Instructions"
				Suffix="Remainder"
				FromIndex="GelReferenceRemainderInstIdx"
				ToIndex="GelInstruction.GelInstructionIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="RemainderTenantId" ToCol="TenantId" />
			<RelationCol Name="RemainderGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="RemainderInstId" ToCol="GelInstId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelSequence">
		<Relation Name="GelCalls"
				RelationType="Children"
				DbName="gelseq_calls"
				Label="GEL Call Instructions"
				Suffix="Calls"
				FromIndex="GelSequenceIdIdx"
				ToIndex="GelCall.GelCallSequenceIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="TenantId" ToCol="SeqInstTenantId" />
			<RelationCol Name="GelCacheId" ToCol="SeqInstGelCacheId" />
			<RelationCol Name="GelInstId" ToCol="SeqInstId" />
		</Relation>
		<Relation Name="FirstInst"
				RelationType="Lookup"
				DbName="gelseq_rfirst"
				Label="First GEL instruction"
				Suffix="FirstInst"
				FromIndex="GelSequenceFirstInstIdx"
				ToIndex="GelCall.GelCallIdIdx"
				IsRequired="false"
				IsXsdContainer="false"
				 >
			<RelationCol Name="FirstInstTenantId" ToCol="TenantId" />
			<RelationCol Name="FirstInstGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="FirstInstId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="LastInst"
				RelationType="Lookup"
				DbName="gelseq_rlast"
				Label="Last GEL instruction"
				Suffix="LastInst"
				FromIndex="GelSequenceLastInstIdx"
				ToIndex="GelCall.GelCallIdIdx"
				IsRequired="false"
				IsXsdContainer="false"
				 >
			<RelationCol Name="LastInstTenantId" ToCol="TenantId" />
			<RelationCol Name="LastInstGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="LastInstId" ToCol="GelInstId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelSwitch">
		<Relation Name="SwitchLimb"
				RelationType="Children"
				DbName="gelsw_swlmb"
				Label="Switch Limbs"
				Suffix="SwitchLimb"
				FromIndex="GelSwitchIdIdx"
				ToIndex="GelSwitchLimb.GelSwitchLimbSwitchIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelSwitchLimb">
		<Relation Name="Switch"
				RelationType="Parent"
				DbName="gelswlmb_sw"
				Label="Switch"
				Suffix="Switch"
				FromIndex="GelSwitchLimbSwitchIdx"
				ToIndex="GelSwitch.GelSwitchIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="GelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelInstId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="Tenant"
				RelationType="Owner"
				DbName="gelswlmb_tenant"
				Label="Tenant"
				Suffix="Tenant"
				FromIndex="GelSwitchLimbTenantIdx"
				ToIndex="Tenant.TenantIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="Id" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GenFile">
		<Relation Name="SourceBundleGel"
				RelationType="Components"
				DbName="genfil_srcbdlgel"
				Label="GEL Executable"
				Suffix="SrcBundleGel"
				FromIndex="SourceBundleIdx"
				ToIndex="GelExecutable.GelExecutableIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="SourceBundleTenantId" ToCol="TenantId" />
			<RelationCol Name="SourceBundleGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="SourceBundleGelId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="BasePackageGel"
				RelationType="Components"
				DbName="gelfil_baspkggel"
				Label="GEL Executable"
				Suffix="BasePackageGel"
				FromIndex="BasePackageIdx"
				ToIndex="GelExecutable.GelExecutableIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="BasePackageTenantId" ToCol="TenantId" />
			<RelationCol Name="BasePackageGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="BasePackageGelId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="ModuleNameGel"
				RelationType="Components"
				DbName="gelfil_modnamegel"
				Label="GEL Executable"
				Suffix="ModuleNameGel"
				FromIndex="ModuleNameIdx"
				ToIndex="GelExecutable.GelExecutableIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="ModuleNameTenantId" ToCol="TenantId" />
			<RelationCol Name="ModuleNameGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="ModuleNameGelId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="SubPackageGel"
				RelationType="Components"
				DbName="gelfil_subpkggel"
				Label="GEL Executable"
				Suffix="SubPackageGel"
				FromIndex="SubPackageIdx"
				ToIndex="GelExecutable.GelExecutableIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="SubPackageTenantId" ToCol="TenantId" />
			<RelationCol Name="SubPackageGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="SubPackageGelId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="ExpansionClassNameGel"
				RelationType="Components"
				DbName="gelfil_expclsnmgel"
				Label="GEL Executable"
				Suffix="ExpClassGel"
				FromIndex="ExpansionClassNameIdx"
				ToIndex="GelExecutable.GelExecutableIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="ExpansionClassNameTenantId" ToCol="TenantId" />
			<RelationCol Name="ExpansionClassNameGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="ExpansionClassNameGelId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="ExpansionKeyNameGel"
				RelationType="Components"
				DbName="gelfil_expkeynmgel"
				Suffix="ExpKeyNameGel"
				FromIndex="ExpansionKeyNameIdx"
				ToIndex="GelExecutable.GelExecutableIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="ExpansionKeyNameTenantId" ToCol="TenantId" />
			<RelationCol Name="ExpansionKeyNameGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="ExpansionKeyNameGelId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="ExpFileNameGel"
				RelationType="Components"
				DbName="gelfil_expflnmgel"
				Suffix="ExpFileNameGel"
				FromIndex="ExpansionFileNameIdx"
				ToIndex="GelExecutable.GelExecutableIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="ExpansionFileNameTenantId" ToCol="TenantId" />
			<RelationCol Name="ExpansionFileNameGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="ExpansionFileNameGelId" ToCol="GelInstId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GenItem">
		<Relation Name="Tenant"
				RelationType="Owner"
				DbName="genitm_tenant"
				Label="Tenant"
				Suffix="Tenant"
				FromIndex="GenItemTenantIdx"
				ToIndex="Tenant.TenantIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="Id" />
		</Relation>
		<Relation Name="Cartridge"
				RelationType="Container"
				DbName="genitm_cart"
				Label="Cartridge"
				Suffix="Cartridge"
				FromIndex="GenItemCartIdx"
				ToIndex="RuleCart.RuleCartIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="CartridgeId" ToCol="Id" />
		</Relation>
		<Relation Name="RuleType"
				RelationType="Lookup"
				DbName="genitm_rltyp"
				Label="RuleType"
				Suffix="RuleType"
				FromIndex="GenItemRuleTypeIdx"
				ToIndex="RuleType.RuleTypeIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="RuleTypeId" ToCol="Id" />
		</Relation>
		<Relation Name="ToolSet"
				RelationType="Lookup"
				DbName="genitm_toolset"
				Label="ToolSet"
				Suffix="ToolSet"
				FromIndex="GenItemToolSetIdx"
				ToIndex="ToolSet.ToolSetIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ToolSetId" ToCol="Id" />
		</Relation>
		<Relation Name="ScopeDef"
				RelationType="Lookup"
				DbName="genitem_scopdef"
				Label="ScopeDef"
				Suffix="ScopeDef"
				FromIndex="GenItemScopeIdx"
				ToIndex="DefClass.DefClassIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="ScopeDefId" ToCol="Id" />
		</Relation>
		<Relation Name="GenDef"
				RelationType="Lookup"
				DbName="genitm_gendef"
				Label="GenDef"
				Suffix="GenDef"
				FromIndex="GenItemGenDefIdx"
				ToIndex="DefClass.DefClassIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="GenDefId" ToCol="Id" />
		</Relation>
		<Relation Name="GelExecutable"
				RelationType="Components"
				DbName="genitm_gelexec"
				Label="GEL Executable"
				Suffix="GelExec"
				FromIndex="GenItemGelExecutableIdx"
				ToIndex="GelExecutable.GelExecutableIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="GelExecutableTenantId" ToCol="TenantId" />
			<RelationCol Name="GelExecutableGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="GelExecutableId" ToCol="GelInstId" />
		</Relation>
		<Relation Name="Probe"
				RelationType="Lookup"
				DbName="genitm_probe"
				Label="GenItem Probe Link"
				Suffix="Probe"
				FromIndex="GenItemProbeIdx"
				ToIndex="GenItem.GenItemIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="ProbeTenantId" ToCol="TenantId" />
			<RelationCol Name="ProbeCartridgeId" ToCol="CartridgeId" />
			<RelationCol Name="ProbeGenItemId" ToCol="ItemId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GenRule">
		<Relation Name="BodyGel"
				RelationType="Components"
				DbName="genrul_bodygel"
				Label="GEL Executable"
				Suffix="BodyGel"
				FromIndex="BodyIdx"
				ToIndex="GelExecutable.GelExecutableIdIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="BodyTenantId" ToCol="TenantId" />
			<RelationCol Name="BodyGelCacheId" ToCol="GelCacheId" />
			<RelationCol Name="BodyGelId" ToCol="GelInstId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="RuleCart">
		<Relation Name="Tenant"
				RelationType="Container"
				DbName="rulcart_tenant"
				Label="Tenant"
				Suffix="Tenant"
				FromIndex="RuleCartTenant"
				ToIndex="Tenant.TenantIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="TenantId" ToCol="Id" />
		</Relation>
		<Relation Name="Rules"
				RelationType="Components"
				DbName="rulecart_rules"
				Label="Rule"
				Suffix="Rule"
				FromIndex="RuleCartIdIdx"
				ToIndex="GenItem.GenItemCartIdx"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="TenantId" ToCol="TenantId" />
			<RelationCol Name="Id" ToCol="CartridgeId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="Tenant">
		<Relation Name="TenantRuleCart"
				RelationType="Components"
				DbName="tenant_rulecart"
				Label="Rule Cartridge"
				Suffix="RuleCart"
				FromIndex="TenantIdIdx"
				ToIndex="RuleCart.RuleCartTenant"
				IsRequired="false"
				IsXsdContainer="true"
				 >
			<RelationCol Name="Id" ToCol="TenantId" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="Tool">
		<Relation Name="ToolReplaces"
				RelationType="Lookup"
				DbName="tool_tlrepl"
				Label="Replaces"
				Suffix="Replaces"
				FromIndex="ToolReplacesIdx"
				ToIndex="Tool.ToolIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="ReplacesId" ToCol="Id" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="ToolSet">
		<Relation Name="Tool0"
				RelationType="Lookup"
				DbName="toolset_tl0"
				Label="Tool0"
				Suffix="Tool0"
				FromIndex="ToolSetTool0Idx"
				ToIndex="Tool.ToolIdIdx"
				IsRequired="true"
				 >
			<RelationCol Name="ToolId0" ToCol="Id" />
		</Relation>
		<Relation Name="Tool1"
				RelationType="Lookup"
				DbName="toolset_tl1"
				Label="Tool1"
				Suffix="Tool1"
				FromIndex="ToolSetTool1Idx"
				ToIndex="Tool.ToolIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="ToolId1" ToCol="Id" />
		</Relation>
		<Relation Name="Tool2"
				RelationType="Lookup"
				DbName="toolset_tl2"
				Label="Tool2"
				Suffix="Tool2"
				FromIndex="ToolSetTool2Idx"
				ToIndex="Tool.ToolIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="ToolId2" ToCol="Id" />
		</Relation>
		<Relation Name="Tool3"
				RelationType="Lookup"
				DbName="toolset_tl3"
				Label="Tool3"
				Suffix="Tool3"
				FromIndex="ToolSetTool3Idx"
				ToIndex="Tool.ToolIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="ToolId3" ToCol="Id" />
		</Relation>
		<Relation Name="Tool4"
				RelationType="Lookup"
				DbName="toolset_tl4"
				Label="Tool4"
				Suffix="Tool4"
				FromIndex="ToolSetTool4Idx"
				ToIndex="Tool.ToolIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="ToolId4" ToCol="Id" />
		</Relation>
		<Relation Name="Tool5"
				RelationType="Lookup"
				DbName="toolset_tl5"
				Label="Tool5"
				Suffix="Tool5"
				FromIndex="ToolSetTool5Idx"
				ToIndex="Tool.ToolIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="ToolId5" ToCol="Id" />
		</Relation>
		<Relation Name="Tool6"
				RelationType="Lookup"
				DbName="toolset_tl6"
				Label="Tool6"
				Suffix="Tool6"
				FromIndex="ToolSetTool6Idx"
				ToIndex="Tool.ToolIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="ToolId6" ToCol="Id" />
		</Relation>
		<Relation Name="Tool7"
				RelationType="Lookup"
				DbName="toolset_tl7"
				Label="Tool7"
				Suffix="Tool7"
				FromIndex="ToolSetTool7Idx"
				ToIndex="Tool.ToolIdIdx"
				IsRequired="false"
				 >
			<RelationCol Name="ToolId7" ToCol="Id" />
		</Relation>
	</TableAddendum>

	<TableAddendum FromTable="GelConstrain">
		<DelDep Name="DelRemainder" DelDepChain="Remainder" />
	</TableAddendum>

	<TableAddendum FromTable="GelModifier">
		<DelDep Name="DelRemainder" DelDepChain="Remainder" />
	</TableAddendum>

	<TableAddendum FromTable="GelPop">
		<DelDep Name="DelRemainder" DelDepChain="Remainder" />
	</TableAddendum>

	<TableAddendum FromTable="GelPrefixLine">
		<DelDep Name="DelRemainder" DelDepChain="Remainder" />
	</TableAddendum>

	<TableAddendum FromTable="GelReference">
		<DelDep Name="DelRemainder" DelDepChain="Remainder" />
	</TableAddendum>

	<TableAddendum FromTable="GelSequence">
		<DelDep Name="DelCalledSequence" DelDepChain="GelCalls" />
	</TableAddendum>

	<TableAddendum FromTable="GelSwitch">
		<DelDep Name="DelSwitchLimb" DelDepChain="SwitchLimb" />
	</TableAddendum>

	<TableAddendum FromTable="GenItem">
		<DelDep Name="DelGelExecutable" DelDepChain="GelExecutable" />
	</TableAddendum>

	<TableAddendum FromTable="RuleCart">
		<DelDep Name="DelRules" DelDepChain="Rules" />
	</TableAddendum>

	<TableAddendum FromTable="Tenant">
		<DelDep Name="DelRuleCart" DelDepChain="TenantRuleCart" />
	</TableAddendum>
</SchemaDef>
						</MinorVersion>
					</MajorVersion>
				</SubProject>
			</TopProject>
		</TopDomain>
	</Tld>
</MSSBam>
